[{"title":"我的北捷少女","path":"2022/10/09/我的北捷少女/","text":"我是一個平凡無奇的大學生，沒有女朋友，然而更可悲的是，星期一到五都有早八，每天不得不在早上七點，勉強撐起那仍渴望著睡眠的身軀，準備去學校經歷知識的陶冶，而殊不知這一去，就要到晚上六點才能回到我那溫馨的小窩，也就是我的家。回到家之後，我立刻打開了筆電，做的事無非就是進入youtube看看影片，又或著是打開不能說的網站尋找好康，為的就是把一天累積的壓力給宣洩出去。不過根據相對論，愉快的時間總是過得特別快，時鐘上的短針不知不覺間已經指到了11，這是要睡覺的信號，有很多人問我為什麼要這麼早睡，說什麼大學生都沒在睡覺之類的話語，感覺我就像是個怪人似的，但他們不知道的是，我的目的是每天睡滿8小時，並且在睡前一定喝一杯溫牛奶，做20分鐘的柔軟操，上了床，馬上熟睡，一覺到天亮。這是一種堅持，是一種原則，甚至是我一生的使命。日復一日，正當我以為大學的這四年都要這麼度過時，在四月的某一天，卻發生了一件事，徹底的改變了我的命運。 那天，下午六點的鐘聲一響，我一如往常的拿起書包，獨自一人準備朝著捷運站走去，然而，我突然停下了腳步，意識到了一件事「明天，好像有離散數學的小考欸」我自言自語的這麼說著 竟然把這麼重要的事情給忘得一乾二淨，實在是挺佩服我自己的，同時，我重新整理了思緒，打開手機的tronclass APP，試圖查詢課表，求得考試時間「欸都，星期二..第8節…，有了，15:10分!!」現在時間距離下課剛好5分鐘，經過了簡單的計算，目前離考試時間僅僅只剩下21個小時又5分鐘，狀況可說是十分悲觀，我意識到時間所剩不多了，分秒必爭，就連這通勤的時間也必須盡可能地縮短「沒時間讓我哭哭啼啼了!!」我試著振奮自己並逐漸邁開步伐「全神貫注!!」接著模仿遊戲裡的技能以減少起步時間，避免時間的浪費 「呼阿..呼阿..總算…來到..這裡了」一分鐘過去，我已是上氣不接下氣的狀態，卻還是勉強的從工學大樓來到了這裡，也就是克難波的入口「這到底什麼鬼天氣阿!」我看著天空試圖宣洩不滿，心想著現在明明才四月，卻早已相當炎熱，讓人有身在烤箱內的錯覺，現在就已經這樣了，真不敢想像到了七月左右會變成什麼樣子呢。在稍微抱怨完之後，我將視線往下移，映入眼簾的是我的衣服，早已被汗水浸溼，但我並沒有帶任何備用的衣物，只能用隨身攜帶的手帕稍微擦一擦忍耐一下。 在經過了短暫的休息之後，我重新邁開步伐，一步當兩步用，迅速的征服了克難波，再繼續前進之前，我轉頭看一眼剛被我攻略的坡道，確實，若是上坡，要攻略的話就不是那麼容易了，但「總有一天，等我變得更強之後，一定會成功登頂的!」我抬起右手指著剛走下來的地方這麼說道，同時露出一抹自信的微笑，接著繼續趕路。 說時遲那時快，轉眼間已經來到了淡水捷運站了，接著我只要拿出悠遊卡，貼在感應處上就可以進站了，但正當我這麼做時「欸，怎麼沒反應阿」我已經將悠遊卡靠在了感應機上，但是閘門卻不為所動，嘗試換了幾台感應機都是一樣的結果「難道，就只能止步於此了嗎」我一路跋山涉水，經歷了重重難關，好不容易才來到這裡，最終擊敗我的卻是區區幾台感應機「明明就..只差一步..就..只差一步了..」我雙腿癱軟，跌坐在地上，眼神充滿了絕望，心中滿是後悔，如果我今天選擇騎YouBike，是不是就不會遇到這種事，如果我今天選擇搭輕軌，是不是已經早已到家，開始搶救我的離散數學了呢 「請..請等一下!!」此時在我後方出現了一個未曾聽過的聲音，聲音中帶著一點輕柔、溫暖，我轉頭一看，是一名少女，看似16、17歲，有著到腰的黑髮，穿著似乎是學校的制服，襪子剛好到膝蓋以下，裙子長度則是非常危險，感覺一陣風吹過來就會看到什麼不該看的東西似的 「怎..怎..怎麼了?」這是我這個月，這一學期，甚至是整個大學生涯，第一次跟女生說話，因此在我的話語中帶著明顯的發抖「那個..刷健保卡是進不了站的喔」我一時之間思緒跟不上，想著她到底在說什麼，但我很快的就意識到，現在拿在我手中的，不是悠遊卡，而是健保卡，沒想到如此尷尬的事竟然會發生在我身上「痾..欸..對欸，謝謝妳，那..我先走了」跟這名少女道謝之後，我想趕快逃離這個現場，畢竟實在是太糗了，在這裡每多待上一秒都是一種折磨，不過就在我確認完這次手上拿的真的是悠遊卡，準備進站時「那個..那個..你等一下有空嗎」那名少女再次向我搭話，但是所說的話十分令人遐想阿，等一下有空嗎?這話到底什麼意思呢，我應該如實告訴她再不回去救我的離散數學明天就完蛋了，還是說…，正當我還在想著該如何答覆時，少女又開口了「其實…」她說她是從日本來的交換學生，但是下個月就要回去了，不過還有些想去的地方一直沒有去過，那就是…淡水信義線 淡水信義線，路線代號為R，路線代表色為紅色，是台北捷運一條營運中的高運量路線及台北捷運唯一一條有高架路段與平面路段的高運量路線。依興建期間與階段營運所使用的路線名稱，此路線又可再細分為淡水線和信義線兩路段，兩線以中正紀念堂站為分界，以北為淡水線，以東為信義線，其中淡水線是臺灣首條由傳統鐵路改建而成的捷運路線，其前身為臺灣鐵路管理局已經停止營運的同名支線鐵路線—臺鐵淡水線。除了主線外，北投區境內設有一條支線—新北投支線。目前正在興建象山站東延至廣慈/奉天宮站的延伸線，完成主線的最後一哩路。 這是我對這個路線的一些基本的了解 那名少女說在她回去日本前，想要沿著這條路線，一站一站的去遊玩，去體驗，不過因為她對於這個地方不是很熟悉，需要一個類似導遊的人物，而被找上的那個人，是我「果然…不行嗎」她再度向我進行確認，語氣中帶著點微微的失落，並將眼神飄向別處，看著這般神情的她，拒絕，是我絕對無法說出口的。 在名為人生的這條路上，我走的可說是相當坎坷，書讀不好，運動也不擅長，就連建立基本的人際關係，對我來說也是相當大的困難，從小到大，交到的朋友數量屈指可數，讓不少親人師長對我的狀況相當擔心，什麼事都做不好、沒有人會需要你，這是別人對我的評論。但是現在，這名少女，向我請求了幫助，如果我在此拒絕，不是又重蹈覆轍了嗎，這樣下去我不就又只能繼續當個封閉者了嗎? 不行，不能在這樣了，我勢必得做出改變「如..如..如果妳不介意的話，是可以啦」這是我下定決心之後說出的話，雖然稱不上是帥氣，但這一步，我還是跨出來了，封閉的內心開始產生了一點裂縫，敲擊它的不是別人，正是在我眼前的少女「真的?可以嗎?」「嗯，雖然有些地方我也不是很熟悉，但我會盡力的」「やったー」她好像是因為太開心了，竟然講出了日文，不過我的目光完全被她的笑容吸引了過去，不知道為什麼，感覺內心深處有什麼即將要改變。 四月的某一天，在淡水捷運站，我遇到了一名少女，與她做出了約定，要帶她觀賞淡水信義線每一站的風景，我們的旅程，隨著下一班的電車在月台進站而開始了…"},{"title":"計程三口試-掃地機器人","path":"2022/05/07/計程三口試-掃地機器人/","text":"口試，是通往計程四之前的最後一戰，採線上的方式進行，預約制，我預約的時間為4/23 10:00，前一天想當然的興奮到差點睡不著覺。到了當天，8:00起床，內心還是十分緊張，不斷重複確認自己的程式碼，為的就是被問問題時能夠流暢的回答出來。到了9:55，教授已經開啟了google meet，戰場就在前方，現在的我，就是一名戰士。到了10:05，口試結束，沒想到教授問的問題比我想像中的少，就大概確認一下這程式是你寫的而已，安全下庄。 總共有11題，前面9題都是為了引導你做出第10題的，最後一題則是加分用，那麼就開始吧。 第1~5題 建立一個名為Robot的class，再加上題目指定的變數即可，注意其皆為private。 C++ 1234567891011class Robot&#123; private: int x; int y; int chargingX; int chargingY; int power; int maxPower; int targetX; int targetY;&#125;; 在Robot類別內，建立一個沒有參數的建構子，為變數賦值。 C++ 1234class Robot&#123; public: Robot(): x(0), y(0), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125;&#125;; 在Robot類別內，建立一個有參數的建構子，設定目前位置為傳入的值。 C++ 1234class Robot&#123; public: Robot(int a, int b): x(a), y(b), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125;&#125;; 在Robot類別內，建立題目指定之methods，使用public使其可以從外部設定與讀取。顯示資料的部分則可以利用gotoxy()函式(定義先省略)，在指定位置輸出。這邊我另外加上了PowerPro()，用來回傳電量比例。 C++ 123456789101112131415161718192021222324252627282930313233343536class Robot&#123; public: void SetLocation(int a, int b)&#123; x = a; y = b; &#125; void SetChargingLocation(int cx, int cy)&#123; chargingX = cx; chargingY = cy; &#125; void SetPower(int p)&#123; power = p; &#125; void SetMaxPower(int p)&#123; maxPower = p; &#125; double PowerPro()&#123; return (double)power/(double)maxPower*100.0; &#125; void SetTargetLocation(int tx, int ty)&#123; targetX = tx; targetY = ty; &#125; void Status()&#123; gotoxy(0, 16); cout &lt;&lt; &quot;Location = (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) &quot;; gotoxy(0, 17); cout &lt;&lt; &quot;Charging Location = (&quot; &lt;&lt; chargingX &lt;&lt; &quot;,&quot; &lt;&lt; chargingY &lt;&lt; &quot;) &quot;; gotoxy(0, 18); cout &lt;&lt; &quot;Power = &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; PowerPro() &lt;&lt; &quot;% &quot;; gotoxy(0, 19); cout &lt;&lt; &quot;Target Location = (&quot; &lt;&lt; targetX &lt;&lt; &quot;,&quot; &lt;&lt; targetY &lt;&lt; &quot;) &quot;; gotoxy(0, 20); &#125;&#125;; 新增一個移動的method，根據目前位置和目的位置，對x, y做比較，不斷更新目前位置，直到其到達目的地。 C++ 1234567891011121314class Robot&#123; public: void MoveTo()&#123; if(x == targetX &amp;&amp; y == targetY) return; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; targetX) ++x; else if(x &gt; targetX) --x; if(y &lt; targetY) ++y; else if(y &gt; targetY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125;&#125;; 接著建立一個Robot型態無參數的物件robot1，利用之前所寫的method設定目前位置與目的位置，就可以開始移動了。 HideCursor()函數用來隱藏光標。 同上一題，只是變成有參數。 照著題目走即可。 C++ 123456789101112131415161718int main()&#123; Robot *robot1 = new Robot(); Robot *robot2 = new Robot(20, 20); robot1-&gt;SetLocation(0, 0); robot1-&gt;SetChargingLocation(10, 10); robot1-&gt;SetPower(150); robot1-&gt;SetMaxPower(150); robot1-&gt;SetTargetLocation(20, 20); robot2-&gt;SetLocation(50, 30); robot2-&gt;SetChargingLocation(10, 10); robot2-&gt;SetPower(20); robot2-&gt;SetMaxPower(100); robot2-&gt;SetTargetLocation(15, 15); return 0;&#125; 用一個迴圈讓兩部機器人輪流移動，利用Sleep()函數製造延遲，不然會機器人順移，狀態就先不顯示了。 到目前為止的程式碼如下 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;using namespace std;void gotoxy(int x, int y)&#123; COORD pos; HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);// 獲取標準輸出裝置控制代碼 pos.X = x, pos.Y = y; SetConsoleCursorPosition(hOut, pos);//兩個引數分別是指定哪個窗體，具體位置&#125;void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;class Robot&#123; private: int x; int y; int chargingX; int chargingY; int power; int maxPower; int targetX; int targetY; public: Robot(): x(0), y(0), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125; Robot(int a, int b): x(a), y(b), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125; void SetLocation(int a, int b)&#123; x = a; y = b; &#125; void SetChargingLocation(int cx, int cy)&#123; chargingX = cx; chargingY = cy; &#125; void SetPower(int p)&#123; power = p; &#125; void SetMaxPower(int p)&#123; maxPower = p; &#125; double PowerPro()&#123; return (double)power/(double)maxPower*100.0; &#125; void SetTargetLocation(int tx, int ty)&#123; targetX = tx; targetY = ty; &#125; void Status()&#123; gotoxy(0, 16); cout &lt;&lt; &quot;Location = (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) &quot;; gotoxy(0, 17); cout &lt;&lt; &quot;Charging Location = (&quot; &lt;&lt; chargingX &lt;&lt; &quot;,&quot; &lt;&lt; chargingY &lt;&lt; &quot;) &quot;; gotoxy(0, 18); cout &lt;&lt; &quot;Power = &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; PowerPro() &lt;&lt; &quot;% &quot;; gotoxy(0, 19); cout &lt;&lt; &quot;Target Location = (&quot; &lt;&lt; targetX &lt;&lt; &quot;,&quot; &lt;&lt; targetY &lt;&lt; &quot;) &quot;; gotoxy(0, 20); &#125; void MoveTo()&#123; if(x == targetX &amp;&amp; y == targetY) return; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; targetX) ++x; else if(x &gt; targetX) --x; if(y &lt; targetY) ++y; else if(y &gt; targetY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125;&#125;;int main()&#123; HideCursor(); Robot *robot1 = new Robot(); Robot *robot2 = new Robot(20, 20); robot1-&gt;SetLocation(0, 0); robot1-&gt;SetChargingLocation(10, 10); robot1-&gt;SetPower(150); robot1-&gt;SetMaxPower(150); robot1-&gt;SetTargetLocation(20, 20); robot2-&gt;SetLocation(50, 30); robot2-&gt;SetChargingLocation(10, 10); robot2-&gt;SetPower(20); robot2-&gt;SetMaxPower(100); robot2-&gt;SetTargetLocation(15, 15); while(true)&#123; robot1-&gt;MoveTo(); robot2-&gt;MoveTo(); Sleep(200); &#125; return 0;&#125; 目前成果如下 第6~9題 在移動的method中，根據電量比例做判斷，若低於10%，則將目標設為充電站位置，若否，則繼續前進。 C++ 123456789101112131415161718192021222324void MoveTo()&#123; if(x == targetX &amp;&amp; y == targetY) return; if(PowerPro() &gt;= 10)&#123; power -= 5; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; targetX) ++x; else if(x &gt; targetX) --x; if(y &lt; targetY) ++y; else if(y &gt; targetY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125; else &#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; chargingX) ++x; else if(x &gt; chargingX) --x; if(y &lt; chargingY) ++y; else if(y &gt; chargingY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125;&#125; 照著題目走即可，這邊我建立一個CapacityPro()，方便取得容量比例。 需注意Status()呼叫的是父類別的Status()，以免造成遞迴，SetTargetLocation()也是。 C++ 12345678910111213141516171819202122232425262728class SweeperRobot:public Robot&#123; private: int capacity; int maxCapacity; public: SweeperRobot():Robot()&#123;&#125; SweeperRobot(int a, int b, int ca, int cb, int n):Robot(a, b, ca, cb)&#123; capacity = 0; maxCapacity = n; &#125; void SetCapacity(int c)&#123; capacity = c; &#125; void SetMaxCapacity(int c)&#123; maxCapacity = c; &#125; void SetTargetLocation(int tx, int ty)&#123; Robot::SetTargetLocation(tx, ty); &#125; double CapacityPro()&#123; return (1.0-(double)capacity/(double)maxCapacity)*100.0; &#125; void Status()&#123; Robot::Status(); cout &lt;&lt; &quot;Capacity = &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; CapacityPro() &lt;&lt; &quot;% &quot;; &#125;&#125;; 多了一個容量要判斷，這邊由於我實現移動的方式都寫在父類別，但是容量是屬於子類別的member，因此需在子類別的MoveTo()中呼叫父類別的MoveTo()時，傳入容量比例，也就是前面所寫的CapacityPro()。 C++ 12345678910111213141516171819202122232425262728293031323334353637class Robot&#123; public: void MoveTo(double CapacityPro)&#123; if(x == targetX &amp;&amp; y == targetY) return; if(PowerPro() &gt;= 10 &amp;&amp; CapacityPro &gt;= 5)&#123; power -= 5; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; targetX) ++x; else if(x &gt; targetX) --x; if(y &lt; targetY) ++y; else if(y &gt; targetY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125; else &#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; chargingX) ++x; else if(x &gt; chargingX) --x; if(y &lt; chargingY) ++y; else if(y &gt; chargingY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125; &#125;&#125;;class SweeperRobot:public Robot&#123; private: int capacity; int maxCapacity; public: void MoveTo()&#123; Robot::MoveTo(CapacityPro()); &#125;&#125;; 第10題 前面的1~9題就是為了這題而生的，不過這裡需具現化一個垃圾的物件，內容很簡單，有x, y 座標，並且在建構的時候隨機生成在螢幕上即可。 C++ 123456789101112131415161718192021class Garbage&#123; private: int x; int y; public: int GetX()&#123; return x; &#125; int GetY()&#123; return y; &#125; Garbage()&#123; x = rand() % width; y = rand() % height; show(); &#125; void show()&#123; gotoxy(x, y); cout &lt;&lt; &quot;G&quot;; &#125;&#125;; 垃圾是每秒生成一個，所以勢必要有一個容器來儲存，這裡我使用了queue，根據其「先進先出」的特性，便可將機器人目標設為最早生成的垃圾，若清除成功，則將垃圾從queue中移除，不斷重複，若場上沒垃圾則會停在上一次清除垃圾的地方。 C++ 1234567891011121314151617181920212223242526int main()&#123; int time = 0; queue&lt;Garbage*&gt; q; Garbage * gar = new Garbage(); q.push(gar); Garbage *temp = q.front(); while(true)&#123; Sleep(20); ++time; if(!q.empty())&#123; temp = q.front(); srobot-&gt;SetTargetLocation(temp-&gt;GetX(), temp-&gt;GetY()); if(srobot-&gt;clearSuc())&#123; //clearSuc()用來判斷機器人是否走到垃圾位置 q.pop(); delete temp; &#125; &#125; if(time % 50 == 0)&#123; //每過1秒生成一個垃圾 Garbage * gar = new Garbage(); q.push(gar); &#125; srobot-&gt;MoveTo(); &#125; return 0;&#125; 根據題目要求，回到充電站不能同時進行充電與清空垃圾，因次需額外判斷此次回充電站之目的為何，這邊我在父類別的MoveTo()設了一個bool型態的回傳值，若為true，代表目的為清空垃圾，回到子類別中實現，完整程式碼如下 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;using namespace std;#define width 80#define height 15void gotoxy(int x, int y)&#123; COORD pos; HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);// 獲取標準輸出裝置控制代碼 pos.X = x, pos.Y = y; SetConsoleCursorPosition(hOut, pos);//兩個引數分別是指定哪個窗體，具體位置&#125;void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;class Robot&#123; private: int x; int y; int chargingX; int chargingY; int power; int maxPower; int targetX; int targetY; public: Robot(): x(0), y(0), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125; Robot(int a, int b): x(a), y(b), chargingX(0), chargingY(0), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125; Robot(int a, int b, int ca, int cb): x(a), y(b), chargingX(ca), chargingY(cb), power(100), maxPower(100), targetX(0), targetY(0)&#123;&#125; void SetLocation(int a, int b)&#123; x = a; y = b; &#125; void SetChargingLocation(int cx, int cy)&#123; chargingX = cx; chargingY = cy; &#125; void SetPower(int p)&#123; power = p; &#125; void SetMaxPower(int p)&#123; maxPower = p; &#125; double PowerPro()&#123; return (double)power/(double)maxPower*100.0; &#125; void SetTargetLocation(int tx, int ty)&#123; targetX = tx; targetY = ty; &#125; bool clearSuc()&#123; if(x == targetX &amp;&amp; y == targetY) return true; return false; &#125; void Status()&#123; gotoxy(0, 16); cout &lt;&lt; &quot;Location = (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) &quot;; gotoxy(0, 17); cout &lt;&lt; &quot;Charging Location = (&quot; &lt;&lt; chargingX &lt;&lt; &quot;,&quot; &lt;&lt; chargingY &lt;&lt; &quot;) &quot;; gotoxy(0, 18); cout &lt;&lt; &quot;Power = &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; PowerPro() &lt;&lt; &quot;% &quot;; gotoxy(0, 19); cout &lt;&lt; &quot;Target Location = (&quot; &lt;&lt; targetX &lt;&lt; &quot;,&quot; &lt;&lt; targetY &lt;&lt; &quot;) &quot;; gotoxy(0, 20); &#125; bool MoveTo(double CapacityPro)&#123; if(x == targetX &amp;&amp; y == targetY) return false; if(PowerPro() &gt;= 10 &amp;&amp; CapacityPro &gt;= 5)&#123; power -= 5; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; targetX) ++x; else if(x &gt; targetX) --x; if(y &lt; targetY) ++y; else if(y &gt; targetY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125; else &#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(x &lt; chargingX) ++x; else if(x &gt; chargingX) --x; if(y &lt; chargingY) ++y; else if(y &gt; chargingY) --y; gotoxy(x, y); cout &lt;&lt; &quot;R&quot;; &#125; if(x == chargingX &amp;&amp; y == chargingY)&#123; if(PowerPro() &lt; 10) power = maxPower; else return true; &#125; return false; &#125;&#125;;class SweeperRobot: public Robot&#123; private: int capacity; int maxCapacity; public: SweeperRobot():Robot()&#123;&#125; SweeperRobot(int a, int b, int ca, int cb, int n):Robot(a, b, ca, cb)&#123; capacity = 0; maxCapacity = n; &#125; void SetCapacity(int c)&#123; capacity = c; &#125; void SetMaxCapacity(int c)&#123; maxCapacity = c; &#125; void SetTargetLocation(int tx, int ty)&#123; Robot::SetTargetLocation(tx, ty); &#125; double CapacityPro()&#123; return (1.0-(double)capacity/(double)maxCapacity)*100.0; &#125; void MoveTo(int mode = 0)&#123; bool clearCapacity = Robot::MoveTo(CapacityPro()); if(clearCapacity) capacity = 0; Status(); &#125; void Status()&#123; Robot::Status(); cout &lt;&lt; &quot;Capacity = &quot;; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; CapacityPro() &lt;&lt; &quot;% &quot;; &#125; bool clearSuc()&#123; if(Robot::clearSuc())&#123; capacity += 5; return true; &#125; return false; &#125;&#125;;class Garbage&#123; private: int x; int y; public: int GetX()&#123; return x; &#125; int GetY()&#123; return y; &#125; Garbage()&#123; x = rand() % width; y = rand() % height; show(); &#125; void show()&#123; gotoxy(x, y); cout &lt;&lt; &quot;G&quot;; &#125;&#125;;int main()&#123; srand(time(NULL)); HideCursor(); SweeperRobot *srobot = new SweeperRobot(0, 14, 0, 14, 100); srobot-&gt;SetPower(100); srobot-&gt;SetMaxPower(1000); srobot-&gt;SetTargetLocation(50, 10); int time = 0; queue&lt;Garbage*&gt; q; Garbage * gar = new Garbage(); q.push(gar); Garbage *temp = q.front(); while(true)&#123; Sleep(20); ++time; if(!q.empty())&#123; temp = q.front(); srobot-&gt;SetTargetLocation(temp-&gt;GetX(), temp-&gt;GetY()); if(srobot-&gt;clearSuc())&#123; q.pop(); delete temp; &#125; &#125; if(time % 50 == 0)&#123; Garbage * gar = new Garbage(); q.push(gar); &#125; srobot-&gt;MoveTo(); &#125; return 0;&#125; 執行結果 第11題 就是將本來的電力低於10%改成確保可回到充電站就好，並且前往充電站途中會耗電3。我的想法是先找出當前機器人與充電站之間的最短移動距離，並判斷若移動後所剩餘的電量是否足夠讓其走回充電站，若足夠，則繼續朝向垃圾前進，若否，則前往充電站。程式碼懶得打了= = 後記以上就是全部的題目，感謝各位的收看，打完這篇文章的時候我已經成功晉級到計程四了，可喜可賀阿，前方究竟還有什麼挑戰在等著我呢?我也不知道，想想就刺激。"},{"title":"計程三大會考練習題","path":"2022/04/17/計程三大會考練習題/","text":"經過了漫長的等待，終於要在4/19迎來這學期首次大會考了，這是相當重要的一戰阿，我的命運究竟是從「計算機程式語言三」晉級「計算機程式語言四」，又或著是止步於此呢?將在下周揭曉~ 在幾天前教授上傳了一些練習題，反正閒著也是閒著，就來小試身手一下吧。 第一題 父類別跟main()不能動，基本上跟著題目要求走就好，繼承父類別，創造建構子，此題完成。 C++ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;class Father&#123; private: int money; public: Father()&#123; money = 100; Print(); &#125; Father(int n)&#123; money = n; Print(); &#125; void Print()&#123; cout &lt;&lt; money &lt;&lt; &quot;\\n&quot;; &#125;&#125;;class Child: public Father&#123; public: Child(int n):Father(n)&#123;&#125;&#125;;int main()&#123; int n; cout &lt;&lt; &quot;input money: &quot;; cin &gt;&gt; n; Child *ken = new Child(n); return 0;&#125; 第二題 一樣父類別跟main()不能動。 由於money是private的，不能直接在子類別中使用，因此需利用父類別提供的函式取得其值。 另外因為父類別的Print()跟子類別的Print()名稱重複了，若想在子類別的Print()中呼叫父類別的Print()，要寫成Father::Print()，否則會視為呼叫自己，造成遞迴。 C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;class Father&#123; private: int money; public: Father()&#123; money = 200; &#125; void Print()&#123; cout &lt;&lt; &quot;money= &quot; &lt;&lt; money &lt;&lt; &quot;\\n&quot;; &#125; int MyMoney()&#123; return money; &#125;&#125;;class Child: public Father&#123; private: int book; public: void Print()&#123; int price; cout &lt;&lt; &quot;price: &quot;; cin &gt;&gt; price; book = MyMoney()/price; Father::Print(); cout &lt;&lt; &quot;book= &quot; &lt;&lt; book &lt;&lt; &quot;\\n&quot;; &#125;&#125;;int main()&#123; Child john; john.Print(); return 0;&#125; 第三題 父類別跟main()不能動。 因為Horse跟Donkey都繼承了Animal，擁有個別的leg，而Mule同時繼承了兩者，若在Mule類別內直接呼叫leg，編譯器會不知道你要哪一個，造成錯誤。這裡需使用virtual，將其leg視為一個。 C++ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;class Animal&#123; protected: int leg; public: Animal()&#123; leg = 4; &#125;&#125;;class Horse: virtual public Animal&#123;&#125;;class Donkey: virtual public Animal&#123;&#125;;class Mule: public Horse, public Donkey&#123; public: void Print()&#123; cout &lt;&lt; &quot;Mule has &quot; &lt;&lt; leg &lt;&lt; &quot;legs\\n&quot;; &#125;&#125;;int main()&#123; Mule mule; mule.Print(); return 0;&#125; 第四題 這題就單純把函式完成就好了，然後動態配置記憶體給其物件。 由於myClock是指向物件的指標，呼叫內部函式時需使用 -&gt; 。 C++ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;class Clock&#123; private: int hour; int minute; int second; public: void SetTime(int h, int m, int s)&#123; hour = h; minute = m; second = s; &#125; void WhatTime()&#123; cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; &quot;\\n&quot;; &#125;&#125;;int main()&#123; Clock *myClock = new Clock; int hour, minute, second; cout &lt;&lt; &quot;time= &quot;; cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second; myClock-&gt;SetTime(hour, minute, second); myClock-&gt;WhatTime(); return 0;&#125; 後記其實打完這篇文時已經4/20號了，前幾天有點懶哈哈，不過我們的大會考也因為疫情的關係，從原本的上機考改成選擇加填充題，難度也沒有比較簡單，另外因為助教課有教Java，所以有考一點，然後就錯了…呼叫父類別函式的super.function()記成super::function()，阿我就不會Java嘛 另外還新增了口試這個項目，就是給你一些題目，要我們把程式碼生出來，問你為什麼這樣寫或這行什麼意思之類的，回答不出來還直接零分，萌新我瑟瑟發抖 挑戰一個接著一個，戰鬥一場接著一場，真是永遠都不會無聊的資工系生活呢!"},{"title":"繼承練習0328","path":"2022/03/28/繼承練習0328/","text":"有夠難搞，BUG一堆 內容大概是在螢幕上顯示一些變數，並且用LinkedList串起來，每過一秒變數減1，歸零時刪除。 可以用鍵盤做一些操作。 目前問題是若只剩下一個變數，把他刪除會出事，可能直接強制結束之類的。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#include &lt;windows.h&gt;#include &lt;conio.h&gt;using namespace std;#define Map_Width 50#define Map_Height 30class Node&#123; private: int val; int x; int y; clock_t StartTime; clock_t CurrentTime; public: Node *next; void AddVal()&#123; if(val &lt; 9) ++val; &#125; void ReduceVal()&#123; --val; &#125; int Die()&#123; if(val &lt;= 0) return true; return false; &#125; void Reset()&#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; &#125; Node()&#123; val = 9; x = rand() % Map_Width; y = rand() % Map_Height; StartTime = clock(); CurrentTime = clock(); show(); &#125; ~Node()&#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; &#125; void gotoxy(int xpos, int ypos)&#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void show()&#123; UpDateTime(); gotoxy(x, y); cout &lt;&lt; val; &#125; void UpDateTime()&#123; CurrentTime = clock(); if((double)(CurrentTime-StartTime)/CLOCKS_PER_SEC &gt; 1)&#123; StartTime = clock(); --val; &#125; &#125;&#125;;class LinkedList&#123; private: Node *p; public: void reset()&#123; p-&gt;Reset(); p = NULL; &#125; Node* GetP()&#123; return p; &#125; LinkedList()&#123; p = NULL; &#125; void Insert(Node *newNode)&#123; if(p == NULL)&#123; p = newNode; p-&gt;next = newNode; &#125; else &#123; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; p = newNode; &#125; &#125; void Grow()&#123; if(p != NULL)&#123; Node *buffer = p-&gt;next; do &#123; buffer-&gt;AddVal(); buffer = buffer-&gt;next; &#125;while(p-&gt;next != buffer); &#125; &#125; void Down()&#123; if(p != NULL)&#123; Node *buffer = p-&gt;next; do &#123; buffer-&gt;ReduceVal(); buffer = buffer-&gt;next; &#125;while(p-&gt;next != buffer); &#125; &#125;&#125;;class UI&#123; private: char key; public: void Action(LinkedList *list)&#123; switch (GetKey()) &#123; case &#x27;A&#x27;: case &#x27;a&#x27;: &#123; Node *newNode = new Node; list-&gt;Insert(newNode); break; &#125; case &#x27;+&#x27;: list-&gt;Grow(); break; case &#x27;-&#x27;: list-&gt;Down(); break; default: break; &#125; UpDate(list); &#125; int GetKey()&#123; if(_kbhit())&#123; key = _getch(); return key; &#125; return 0; &#125; void UpDate(LinkedList *list)&#123; if(list-&gt;GetP() != NULL)&#123; Node *p = list-&gt;GetP(); do &#123; p-&gt;show(); if(p-&gt;next-&gt;Die())&#123; Node *buffer = p-&gt;next; if(buffer == p)&#123; list-&gt;reset(); break; &#125; p-&gt;next = p-&gt;next-&gt;next; delete buffer; &#125; p = p-&gt;next; &#125;while(p != list-&gt;GetP()); &#125; &#125;&#125;;void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;int main()&#123; HideCursor(); srand(time(NULL)); LinkedList *list = new LinkedList; UI *ui = new UI; while(true)&#123; ui-&gt;Action(list); &#125; return 0;&#125;"},{"title":"繼承練習0322","path":"2022/03/22/繼承練習0322/","text":"作業內容是將下列C++程式碼改成Java的。 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;using namespace std;class Object&#123; protected: int dmg; public: Object()&#123; dmg = 0; &#125; Object(int x)&#123; dmg = x; &#125; void Action()&#123; cout&lt;&lt;&quot;Do nothing......&quot;&lt;&lt;endl; &#125; void MoveTo(int x, int y)&#123; cout&lt;&lt;&quot;Walking to location(&quot;&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; void Attack(int dmg)&#123; cout&lt;&lt;&quot;Attack.......&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Damage: &quot;&lt;&lt;dmg&lt;&lt;endl; &#125;&#125;;class NPC: public Object&#123;&#125;;class Player: public Object&#123; private: int magicDmg; public: Player()&#123; Object(10); magicDmg = 10; cout&lt;&lt;&quot;dmg = &quot;&lt;&lt;dmg&lt;&lt;endl; cout&lt;&lt;&quot;magicDmg = &quot;&lt;&lt;magicDmg&lt;&lt;endl; &#125; void Action()&#123; MoveTo(10,20); &#125; void Attack()&#123; cout&lt;&lt;&quot;Casting magic......&quot;&lt;&lt;endl; Object::Attack(dmg+magicDmg); &#125;&#125;;class Monster: public Object&#123; public: Monster()&#123; Object(20); cout&lt;&lt;&quot;dmg = &quot;&lt;&lt;dmg&lt;&lt;endl; &#125; void MoveTo(int x, int y)&#123; cout&lt;&lt;&quot;Flying to location(&quot;&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125; void Action()&#123; MoveTo(10,20); Attack(dmg); &#125;&#125;;class Building: public Object&#123;&#125;;int main()&#123; cout&lt;&lt;&quot;NPC: &quot;&lt;&lt;endl; NPC npc; npc.Action(); cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Player: &quot;&lt;&lt;endl; Player player; player.Action(); cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Monster: &quot;&lt;&lt;endl; Monster monster; monster.Action(); cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Player: fight back....&quot;&lt;&lt;endl; player.Attack(); cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Building: &quot;&lt;&lt;endl; Building building; building.Action(); return 0;&#125; 其實這兩種語法感覺上並沒有差太多，大部分時間都花在把 cout 改成 System.out.print(汗，需要注意的是 Java 的繼承是用 extends，還有在子類別呼叫父類別建構子時要使用一個特別的函數 super()，不能直接用父類別名稱呼叫，修改完成的程式碼如下。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package homework0322;class Object&#123; protected int dmg; public Object()&#123; dmg = 0; &#125; public Object(int x)&#123; dmg = x; &#125; public void Action()&#123; System.out.print(&quot;Do nothing......\\n&quot;); &#125; public void MoveTo(int x, int y)&#123; System.out.print(&quot;Walking to location(&quot; + x + &quot;,&quot; + y + &quot;)\\n&quot;); &#125; public static void Attack(int dmg)&#123; System.out.print(&quot;Attack.......\\n&quot;); System.out.print(&quot;Damage: &quot; + dmg + &quot;\\n&quot;); &#125;&#125;;class NPC extends Object&#123;&#125;;class Player extends Object&#123; private int magicDmg; public Player()&#123; super(10); magicDmg = 10; System.out.print(&quot;dmg = &quot; + dmg + &quot;\\n&quot;); System.out.print(&quot;magicDmg = &quot; + magicDmg + &quot;\\n&quot;); &#125; public void Action()&#123; MoveTo(10,20); &#125; public void Attack()&#123; System.out.print(&quot;Casting magic......\\n&quot;); Object.Attack(dmg+magicDmg); &#125;&#125;;class Monster extends Object&#123; public Monster()&#123; super(20); System.out.print(&quot;dmg = &quot; + dmg + &quot;\\n&quot;); &#125; public void MoveTo(int x, int y)&#123; System.out.print(&quot;Flying to location(&quot; + x + &quot;,&quot; + y + &quot;)\\n&quot;); &#125; public void Action()&#123; MoveTo(10,20); Attack(dmg); &#125;&#125;;class Building extends Object&#123;&#125;;public class HW0322 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.print(&quot;NPC: \\n&quot;); NPC npc = new NPC(); npc.Action(); System.out.print(&quot;---------------------------\\n&quot;); System.out.print(&quot;Player: \\n&quot;); Player player = new Player(); player.Action(); System.out.print(&quot;---------------------------\\n&quot;); System.out.print(&quot;Monster: \\n&quot;); Monster monster = new Monster(); monster.Action(); System.out.print(&quot;---------------------------\\n&quot;); System.out.print(&quot;Player: fight back....\\n&quot;); player.Attack(); System.out.print(&quot;---------------------------\\n&quot;); System.out.print(&quot;Building: \\n&quot;); Building building = new Building(); building.Action(); &#125;&#125; 結果"},{"title":"繼承練習0321","path":"2022/03/21/繼承練習0321/","text":"放個程式碼在這，這樣去學校就不用重打ㄌ C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;class Object&#123; protected: int HP; int ATK; int hitRate; public: Object(int hp, int atk, int rate):HP(hp), ATK(atk),hitRate(rate) &#123;&#125; void state()&#123; cout &lt;&lt; &quot;HP: &quot; &lt;&lt; HP &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;ATK: &quot; &lt;&lt; ATK &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;hitRate: &quot; &lt;&lt; hitRate &lt;&lt; &quot;\\n&quot;; &#125; void Attack(Object *obj)&#123; if(rand()%100+1 &lt;= hitRate)&#123; cout &lt;&lt; &quot;Attack sucess!!\\n&quot;; obj-&gt;UnderAttack(ATK); &#125; else cout &lt;&lt; &quot;miss...\\n&quot;; &#125; void UnderAttack(int damage)&#123; HP -= damage; if(HP &lt; 0) HP = 0; cout &lt;&lt; &quot;目前血量: &quot; &lt;&lt; HP &lt;&lt; &quot;\\n&quot;; &#125; int GetHP()&#123; return HP; &#125; bool die()&#123; if(HP &lt;= 0)&#123; return true; &#125; return false; &#125;&#125;;class Player:public Object&#123; private: int Level = 1; public: Player():Object(100, 50, 80)&#123;&#125; void LevelUP()&#123; ++Level; HP += 10; if(Level % 3 == 0) ++ATK; &#125;&#125;;class Monster:public Object&#123; public: Monster():Object(200, 10, 50)&#123;&#125;&#125;;class NPC:public Object&#123; public: NPC():Object(150, 5, 60)&#123;&#125;&#125;;int main()&#123; srand(time(NULL)); Player *player = new Player; Monster *monster = new Monster; NPC *npc = new NPC; player-&gt;state(); monster-&gt;state(); npc-&gt;state(); while(true)&#123; cout &lt;&lt; &quot;player對monster發動攻擊!!\\n&quot;; player-&gt;Attack(monster); cout &lt;&lt; &quot;npc對monster發動攻擊!!\\n&quot;; npc-&gt;Attack(monster); cout &lt;&lt; &quot;monster對player發動攻擊!!\\n&quot;; monster-&gt;Attack(player); if(player-&gt;die())&#123; cout &lt;&lt; &quot;你已經死了!!\\n&quot;; delete player; delete monster; delete npc; break; &#125; if(monster-&gt;die())&#123; player-&gt;LevelUP(); delete monster; Monster *monster = new Monster; &#125; if(npc-&gt;die())&#123; delete npc; NPC *npc = new NPC; &#125; &#125; return 0;&#125;"},{"title":"貪食蛇-遊戲主體","path":"2022/03/06/貪食蛇-遊戲主體/","text":"創造完遊戲基本的物件後，就可以開始做遊戲實際運行的畫面了。 先來回顧一下之前寫的物件 蛇 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Snake&#123;private: int x; int y; int player; bool eat = false; class Body&#123; private: int x; int y; public: int xpos()&#123; return x; &#125; int ypos()&#123; return y; &#125; void setxy(int a, int b)&#123; x = a; y = b; &#125; &#125;; deque&lt;Body&gt; body;public: Body GetBody(int i)&#123; return body[i]; &#125; void gotoxy(int xpos, int ypos) &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void Init()&#123; player = 4; Body head; head.setxy(1, 1); body.clear(); body.push_front(head); &#125; int speed()&#123; return (50 + length()*10); &#125; void move(char key)&#123; Body head = body.front(); if(!eat)&#123; Body tail = body.back(); gotoxy(tail.xpos() + Left_Edge, tail.ypos()); cout &lt;&lt; &quot; &quot;; body.pop_back(); &#125; if(key == &#x27;a&#x27;)&#123; head.setxy(head.xpos()-1, head.ypos()); &#125; else if(key == &#x27;d&#x27;)&#123; head.setxy(head.xpos()+1, head.ypos()); &#125; else if(key == &#x27;w&#x27;)&#123; head.setxy(head.xpos(), head.ypos()-1); &#125; else if(key == &#x27;s&#x27;)&#123; head.setxy(head.xpos(), head.ypos()+1); &#125; gotoxy(head.xpos() + Left_Edge, head.ypos()); cout &lt;&lt; &quot;S&quot;; body.push_front(head); eat = false; &#125; int length()&#123; return body.size(); &#125; int HP()&#123; return player; &#125; void hurt()&#123; --player; &#125; void grow()&#123; eat = true; &#125; bool die()&#123; Body head = body.front(); if(player &lt;= 0) return true; if(head.xpos() &lt; 1 || head.xpos() &gt; Map_Width-1 || head.ypos() &lt; 1 || head.ypos() &gt; Map_Height-1) return true; for(int i = 1; i &lt; body.size(); ++i)&#123; if(head.xpos() == body[i].xpos() &amp;&amp; head.ypos() == body[i].ypos())&#123; return true; &#125; &#125; return false; &#125;&#125;snake; 食物 C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Food&#123;private: bool flag; int x; int y;public: int xpos()&#123; return x; &#125; int ypos()&#123; return y; &#125; void gotoxy(int xpos, int ypos) &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void InitFood()&#123; flag = true; &#125; void CreateFood()&#123; if(flag)&#123; x = rand() % (Map_Width-2) + 1; y = rand() % (Map_Height-2) + 1; for(int i = 0; i &lt; snake.length(); ++i)&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; x = rand() % (Map_Width-2) + 1; y = rand() % (Map_Height-2) + 1; &#125; &#125; bool CreateError = false; for(int i = 0; i &lt; snake.length(); ++i)&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; CreateError = true; break; &#125; &#125; if(CreateError) flag = true; else &#123; gotoxy(x + Left_Edge, y); cout &lt;&lt; &quot;f&quot;; flag = false; &#125; &#125; &#125; void EatFood()&#123; if(x == snake.GetBody(0).xpos() &amp;&amp; y == snake.GetBody(0).ypos())&#123; snake.grow(); flag = true; &#125; &#125; bool exist()&#123; if(flag) return false; else return true; &#125;&#125;food; 回顧完畢 由於蛇撞到邊界會死亡，所以勢必要有一張有限的地圖，這裡我們可以先定義地圖的長、寬，以及地圖左邊界的位置(讓遊戲畫面盡量靠中)。 123#define Map_Width 50 //寬#define Map_Height 30 //長#define Left_Edge 30 //左邊界x值 地圖的邊界可以利用一些簡單的符號以及 gotoxy() 函式來繪製。寫成一個函式之後要用再呼叫。 1234567891011121314void InitScene()&#123; for(int i = 0; i &lt; Map_Width + 1; ++i)&#123; gotoxy(Left_Edge + i, 0); //上邊界 cout &lt;&lt; &quot;-&quot;; gotoxy(Left_Edge + i, Map_Height); //下邊界 cout &lt;&lt; &quot;-&quot;; &#125; for(int i = 1; i &lt; Map_Height; ++i)&#123; gotoxy(Left_Edge - 1, i); //左邊界 cout &lt;&lt; &quot;|&quot;; gotoxy(Left_Edge + Map_Width, i); //右邊界 cout &lt;&lt; &quot;|&quot;; &#125;&#125; 結果 接著就可以想辦法將蛇和食物顯示在螢幕上，並且依照指令行動，就是變成可以玩的樣子。 先將蛇和食物初始化，接著使蛇可以一直根據指令行動，過程中要不斷判斷食物是否需要重新生成(有沒有被吃)，若死亡則遊戲結束。 1234567891011121314151617181920int main()&#123; char Key = &#x27;d&#x27;; //默認向右移動 HideCursor(); //隱藏光標 InitScene(); //繪製地圖 snake.Init(); //蛇初始化 food.InitFood(); //食物初始化 while(true)&#123; //開始遊戲 if(_kbhit())&#123; //若有按鍵則接收輸入 Key = _getch(); &#125; food.CreateFood(); //是否需要生成食物 snake.move(Key); //移動 food.EatFood(); //食物是否被吃 if(snake.die())&#123; //是否死亡 break; &#125; Sleep(100); //移動間隔時間 &#125; return 0;&#125; 最後來簡單做個遊戲結束的畫面好了，順便在遊戲過程中顯示當前分數(蛇的長度)。 將遊戲結束畫面寫成一個函式，在死亡時呼叫即可。 123456void die_UI()&#123; gotoxy(Left_Edge + Map_Width/2, 5); cout &lt;&lt; &quot;你已經死了!!&quot;; gotoxy(Left_Edge + Map_Width/2, 7); cout &lt;&lt; &quot;分數: &quot; &lt;&lt; snake.length();&#125; 一樣寫成一個函式，在無窮迴圈中呼叫。 1234void update()&#123; gotoxy(Left_Edge + Map_Width + 1, 2); cout &lt;&lt; &quot;得點: &quot; &lt;&lt; snake.length() &lt;&lt; &quot; &quot;;&#125; 最終的程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;using namespace std;#define Map_Width 50#define Map_Height 30#define Left_Edge 30class Snake&#123;private: int x; int y; int player; bool eat = false; class Body&#123; private: int x; int y; public: int xpos()&#123; return x; &#125; int ypos()&#123; return y; &#125; void setxy(int a, int b)&#123; x = a; y = b; &#125; &#125;; deque&lt;Body&gt; body;public: Body GetBody(int i)&#123; return body[i]; &#125; void gotoxy(int xpos, int ypos) &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void Init()&#123; player = 4; Body head; head.setxy(1, 1); body.clear(); body.push_front(head); &#125; void move(char key)&#123; Body head = body.front(); if(!eat)&#123; Body tail = body.back(); gotoxy(tail.xpos() + Left_Edge, tail.ypos()); cout &lt;&lt; &quot; &quot;; body.pop_back(); &#125; if(key == &#x27;a&#x27;)&#123; head.setxy(head.xpos()-1, head.ypos()); &#125; else if(key == &#x27;d&#x27;)&#123; head.setxy(head.xpos()+1, head.ypos()); &#125; else if(key == &#x27;w&#x27;)&#123; head.setxy(head.xpos(), head.ypos()-1); &#125; else if(key == &#x27;s&#x27;)&#123; head.setxy(head.xpos(), head.ypos()+1); &#125; gotoxy(head.xpos() + Left_Edge, head.ypos()); cout &lt;&lt; &quot;S&quot;; body.push_front(head); eat = false; &#125; int length()&#123; return body.size(); &#125; void grow()&#123; eat = true; &#125; bool die()&#123; Body head = body.front(); if(player &lt;= 0) return true; if(head.xpos() &lt; 1 || head.xpos() &gt; Map_Width-1 || head.ypos() &lt; 1 || head.ypos() &gt; Map_Height-1) return true; for(int i = 1; i &lt; body.size(); ++i)&#123; if(head.xpos() == body[i].xpos() &amp;&amp; head.ypos() == body[i].ypos())&#123; return true; &#125; &#125; return false; &#125;&#125;snake;class Food&#123;private: bool flag; int x; int y;public: int xpos()&#123; return x; &#125; int ypos()&#123; return y; &#125; void gotoxy(int xpos, int ypos) &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void InitFood()&#123; flag = true; &#125; void CreateFood()&#123; if(flag)&#123; x = rand() % (Map_Width-2) + 1; y = rand() % (Map_Height-2) + 1; for(int i = 0; i &lt; snake.length(); ++i)&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; x = rand() % (Map_Width-2) + 1; y = rand() % (Map_Height-2) + 1; &#125; &#125; bool CreateError = false; for(int i = 0; i &lt; snake.length(); ++i)&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; CreateError = true; break; &#125; &#125; if(CreateError) flag = true; else &#123; gotoxy(x + Left_Edge, y); cout &lt;&lt; &quot;f&quot;; flag = false; &#125; &#125; &#125; void EatFood()&#123; if(x == snake.GetBody(0).xpos() &amp;&amp; y == snake.GetBody(0).ypos())&#123; snake.grow(); flag = true; &#125; &#125;&#125;food;void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;void gotoxy(int xpos, int ypos)&#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn);&#125;void InitScene();void die_UI();void update();int main()&#123; char Key = &#x27;d&#x27;; HideCursor(); InitScene(); snake.Init(); food.InitFood(); while(true)&#123; if(_kbhit())&#123; Key = _getch(); &#125; food.CreateFood(); snake.move(Key); food.EatFood(); update(); if(snake.die())&#123; system(&quot;CLS&quot;); die_UI(); break; &#125; Sleep(100); &#125; return 0;&#125;void InitScene()&#123; for(int i = 0; i &lt; Map_Width + 1; ++i)&#123; gotoxy(Left_Edge + i, 0); cout &lt;&lt; &quot;-&quot;; gotoxy(Left_Edge + i, Map_Height); cout &lt;&lt; &quot;-&quot;; &#125; for(int i = 1; i &lt; Map_Height; ++i)&#123; gotoxy(Left_Edge - 1, i); cout &lt;&lt; &quot;|&quot;; gotoxy(Left_Edge + Map_Width, i); cout &lt;&lt; &quot;|&quot;; &#125;&#125;void die_UI()&#123; gotoxy(Left_Edge + Map_Width/2, 5); cout &lt;&lt; &quot;你已經死了!!&quot;; gotoxy(Left_Edge + Map_Width/2, 7); cout &lt;&lt; &quot;得點: &quot; &lt;&lt; snake.length();&#125;void update()&#123; gotoxy(Left_Edge + Map_Width + 1, 2); cout &lt;&lt; &quot;得點: &quot; &lt;&lt; snake.length() &lt;&lt; &quot; &quot;;&#125; 開玩最基礎的貪食蛇終於完工啦，可以交作業了，但是這樣你滿足了嗎? Are you satisfied? No, I am curious and interested!! 當然不能止步於此，還有各種介面、關卡流程，甚至是 BGM 等著我們來做，你以為全都結束了嗎? 不，這只是最初的起點。 這不是很戲劇化的發展嗎"},{"title":"貪食蛇-遊戲物件","path":"2022/03/05/貪食蛇-遊戲物件/","text":"在貪食蛇遊戲中，有兩個非常重要的物件，分別是蛇和食物，蛇吃到食物會變長，撞到自己身體或牆壁則會死亡，食物被吃掉則會消失，並在隨機點重生。可以用C++中的Class來實現。 蛇遊戲中的主角，也是玩家唯一可以操控的人物(動物?)，基本資料有蛇頭的位置、長度，建議用 private 包起來，避免不小心從外部動到。行為有出生、移動、生長、死亡等等，可以寫成函數的形式。 123456789101112131415161718192021222324252627class Snake&#123;private: int x; int y; int player; //先不要理他 bool eat = false; //是否吃到食物public: void gotoxy(int xpos, int ypos) //控制游標位置 &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void Init()&#123; &#125; void move()&#123; &#125; void grow()&#123; &#125; void die()&#123; &#125;&#125;; 架構大概長這樣，至於身體的部分，先從移動方式下手，觀察後發現，其實可以想成把蛇的尾端去掉，移到蛇頭前(準備要移動的位置)。因為 deque (雙向佇列) 的特性可以輕鬆的從前後端放入和移除資料，所以用其作為儲存身體的資料結構就是一個不錯的選擇。 1234567891011121314151617class Body&#123; private: int x; //每一節身體個別的座標 int y; private: int xpos()&#123; //從外部取得x return x; &#125; int ypos()&#123; //從外部取得y return y; &#125; void setxy(int a, int b)&#123; //從外部設定x, y x = a; y = b; &#125; &#125;; deque&lt;Body&gt; body; 這段直接加在 Snake 類別的 private 即可。 接著來寫出生、移動、生長、死亡等等的程式碼吧 出生其實就是初始化，代表蛇在遊戲一開始的狀態，把 deque 清空，然後放蛇頭進去就好了。 1234567void Init()&#123; player = 4; //先不要理他 Body head; head.setxy(1, 1); body.clear(); //清空 body.push_front(head); //放入蛇頭 &#125; 移動上一篇文章有講到只有一節身體的移動方式，現在要移動一整條蛇，也不難，就按照上面的策略把蛇的尾端去掉，接在頭的前面(要移動到的地點生一節出來)，這邊其實要判斷一下是否有吃到食物，若有，就省略去掉尾端的動作，因為前面還是會生長，所以看起來就變長了。 12345678910111213141516171819202122232425void move(char key)&#123; Body head = body.front(); if(!eat)&#123; //沒吃到食物 Body tail = body.back(); gotoxy(tail.xpos() + Left_Edge, tail.ypos()); //游標移到尾端，Left_Edge是左邊界的位置，我的蛇是在畫面中間移動的，而不是從最左邊開始，之後應該會提到 cout &lt;&lt; &quot; &quot;; //輸出空白 body.pop_back(); //把尾端去掉 &#125; if(key == &#x27;a&#x27;)&#123; head.setxy(head.xpos()-1, head.ypos()); &#125; else if(key == &#x27;d&#x27;)&#123; head.setxy(head.xpos()+1, head.ypos()); &#125; else if(key == &#x27;w&#x27;)&#123; head.setxy(head.xpos(), head.ypos()-1); &#125; else if(key == &#x27;s&#x27;)&#123; head.setxy(head.xpos(), head.ypos()+1); &#125; gotoxy(head.xpos() + Left_Edge, head.ypos()); //游標移到生長點(要移動到的地方) cout &lt;&lt; &quot;S&quot;; body.push_front(head); //把生長出來的身體放入，成為新的頭部 eat = false; //食物吃完了&#125; 生長這邊好像沒什麼東西欸，幾乎都寫在移動了，就是更新成有吃到食物的狀態，然後再進入移動環節。有吃到食物才會呼叫這個函式。 123void grow()&#123; eat = true;&#125; 死亡你已經死了!!什麼!! 用來判斷死了沒，看有沒有碰到自己身體或牆壁 1234567891011bool die()&#123; Body head = body.front(); if(player &lt;= 0) return true; //先不要理他 if(head.xpos() &lt; 1 || head.xpos() &gt; Map_Width-1 || head.ypos() &lt; 1 || head.ypos() &gt; Map_Height-1) return true; //若頭部超出邊界 for(int i = 1; i &lt; body.size(); ++i)&#123; if(head.x == body[i].xpos() &amp;&amp; head.y == body[i].ypos())&#123; //若頭部跟身體相撞了 return true; &#125; &#125; return false; //上述條件都不成立代表你還活著&#125; 其他從外部取得指定的身體部分 123Body GetBody(int i)&#123; return body[i];&#125; 從外部取得蛇的長度 123int length()&#123; return body.size();&#125; 基本的操作大概就這樣，至於 Player 這個變數是幹嘛用的，還有 Left_Edge 是什麼東西，之後應該都會提到。 食物吃的東西，用來使蛇生長的，基本資料有位置、是否存在，行為有出生和被吃(?)等等 1234567891011121314151617181920212223class Food&#123;private: bool flag; //食物存在與否 int x; //食物位置 int y;public: void gotoxy(int xpos, int ypos) //控制游標位置 &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; void InitFood()&#123; &#125; void CreateFood()&#123; &#125; void EatFood()&#123; &#125;&#125;food; 架構大概長這樣，兩行之後，程式碼時間。 出生初始化，將 flag 設為 true，代表食物不存在 123void InitFood()&#123; flag = true;&#125; 接著若食物不存在，就開啟創造模式，隨機生成食物，且不能生長在有蛇的地方，不過可能會有運氣不好的時候，一直生在有蛇的地方，那就將食物視為不存在，下次繼續創造看看，總會有成功的一天。 12345678910111213141516171819202122232425void CreateFood()&#123; if(flag)&#123; x = rand() % (Map_Width-2) + 1; //Map_Width是地圖寬度 y = rand() % (Map_Height-2) + 1; //Map_Height是地圖長度 for(int i = 0; i &lt; snake.length(); ++i)&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; //判斷欲生長點是否有蛇，若有，就換一個點 x = rand() % (Map_Width-2) + 1; y = rand() % (Map_Height-2) + 1; &#125; &#125; bool CreateError = false; for(int i = 0; i &lt; snake.length(); ++i)&#123; //看運氣如何 if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; //看生長位置是否合法 CreateError = true; break; &#125; &#125; if(CreateError) flag = true; else &#123; gotoxy(x + Left_Edge, y); //如果生長成功，就在食物位置輸出 cout &lt;&lt; &quot;f&quot;; flag = false; //食物設為存在 &#125; &#125;&#125; 死亡如果食物位置等於蛇頭位置，蛇生長，食物設定為不存在。 123456void EatFood()&#123; if(x == snake.GetBody(i).xpos() &amp;&amp; y == snake.GetBody(i).ypos())&#123; snake.grow(); flag = true; &#125;&#125; 其他從外部取得x, y 123456int xpos()&#123; return x;&#125;int ypos()&#123; return y;&#125; 此遊戲最重要的兩個物件差不多就完成了，當然，這只是最基礎的功能而已，之後會再加上一些有趣的東西，甚至是新的物件，讓遊戲豐富起來。"},{"title":"貪食蛇-移動","path":"2022/03/05/貪食蛇-移動/","text":"如果要用鍵盤來控制移動方向(w:上 s:下 a:左 d:右)，就要讓電腦知道當下按的鍵，並馬上做出反應，再根據按鍵來決定移動方向。 這裡可以用 _kbhit() 以及 _getch() 這兩個函式來實現此目標。 _kbhit() 是用來檢查當前是否有鍵盤輸入，若否，則回傳 false(無論有無按鍵都會立刻回傳)。_getch() 可以從鍵盤讀入一個字元，回傳字元的 ASCII 值，若沒輸入就會一直卡在那邊。 使用 _kbhit(), _getch() 需要 #include &lt;conio.h&gt; 鍵盤讀取首先，我們先嘗試讓電腦可以不斷印出當下的按鍵為何，用 _kbhit() 來判斷是否有按鍵，若有，則用 _getch() 接收此按鍵，並將其輸出，外面用一個無窮迴圈包著使其可以重複判斷讀取。 C++ 1234567891011121314#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt; // _kbhit() 和 _getch() 需要用到using namespace std;int main()&#123; char Key; while(true)&#123; if(_kbhit())&#123; Key = _getch(); cout &lt;&lt; Key &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125; 結果 移動接著，就可以開始想辦法讓蛇在螢幕上顯示出來，並根據按鍵來移動。 下面是我最初的做法，用 x, y 來儲存蛇當前的位置，若有輸入，判斷按鍵為何，更新 x, y 值，最後用迴圈跑，在對應的 x, y 位置輸出蛇的代號，否則輸出空白，並且適時的換行，在下一次輸入時使用 system(“CLS”) 來達成清屏效果。 C++ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;using namespace std;int main()&#123; char Key; int x = 10, y = 10; while(true)&#123; if(_kbhit())&#123; system(&quot;CLS&quot;); //清屏 Key = _getch(); if(Key == &#x27;d&#x27;) ++x; else if(Key == &#x27;a&#x27;) --x; else if(Key == &#x27;w&#x27;) --y; else if(Key == &#x27;s&#x27;) ++y; for(int i = 0; i &lt; 20; ++i)&#123; for(int j = 0; j &lt; 20; ++j)&#123; if(y == i &amp;&amp; x == j)&#123; cout &lt;&lt; &quot;S&quot;; &#125; else cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; &#125; &#125; return 0;&#125; 這當然不是一個好方法，實在太沒效率了，於是我後來查了一下發現，有 gotoxy() 這個強大的函式，可以用來控制游標位置，舉例來說，如果蛇的位置在 (10, 16)，就可以這樣寫 12gotoxy(10, 16); //將游標位置移動到指定位置cout &lt;&lt; &quot;S&quot;; 就這?沒錯，多麼輕鬆愉快，完全不用使用迴圈，也不用清屏，只要將移動前的位置輸出空白就好了 1234gotoxy(10, 16); //從 (10, 16) 移動到 (10, 17)cout &lt;&lt; &quot; &quot;;gotoxy(10, 17);cout &lt;&lt; &quot;S&quot;; gotoxy() 不是內建的，使用前要自己定義 1234567void gotoxy(int xpos, int ypos) &#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn); &#125; 使用 gotoxy() 需要 #include &lt;windows.h&gt; 改良之後的程式碼 C++ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt; // _kbhit() 和 _getch() 需要用到#include &lt;windows.h&gt; //gotoxy() 需要用到using namespace std;void gotoxy(int xpos, int ypos)&#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn);&#125;int main()&#123; char Key; int x = 10, y = 10; while(true)&#123; if(_kbhit())&#123; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; Key = _getch(); if(Key == &#x27;d&#x27;) ++x; else if(Key == &#x27;a&#x27;) --x; else if(Key == &#x27;w&#x27;) --y; else if(Key == &#x27;s&#x27;) ++y; gotoxy(x, y); cout &lt;&lt; &quot;S&quot;; &#125; &#125; return 0;&#125; 結果 連續移動目前只有按按鍵才會移動，這樣你滿足了嗎? NO, I am curious and interested!! 我們要讓蛇可以自動依照最後一個按鍵方向移動，只要將 _getch() 以外的東西移到 _kbhit()判斷條件外，如此一來就算沒有鍵盤輸入也會按照前一次更新的 Key 值做移動。 但是由於程式運行速度太快，蛇會以10毫秒16步來移動，這顯然不是我們要的，因此，我們需要使用 Sleep() 函式，傳入的值代表程式運行到這裡會在此卡多久(毫秒)，製造移動的時間差。 使用 Sleep() 需要 #include &lt;windows.h&gt; C++ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;using namespace std;void gotoxy(int xpos, int ypos)&#123; COORD scrn; HANDLE hOuput = GetStdHandle(STD_OUTPUT_HANDLE); scrn.X = xpos; scrn.Y = ypos; SetConsoleCursorPosition(hOuput,scrn);&#125;int main()&#123; char Key = &#x27;d&#x27;; int x = 10, y = 10; while(true)&#123; if(_kbhit())&#123; Key = _getch(); &#125; gotoxy(x, y); cout &lt;&lt; &quot; &quot;; if(Key == &#x27;d&#x27;) ++x; else if(Key == &#x27;a&#x27;) --x; else if(Key == &#x27;w&#x27;) --y; else if(Key == &#x27;s&#x27;) ++y; gotoxy(x, y); cout &lt;&lt; &quot;S&quot;; Sleep(200); &#125; return 0;&#125; 結果基本上長差不多，只是鍵盤不用一直按 隱藏光標一直閃看了很不舒服，現在我有 HideCursor() 可以隱藏光標，使用前要自己定義 1234void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125; 在 main() 一開始呼叫即可 12345678910111213以上省略void HideCursor()&#123; CONSOLE_CURSOR_INFO cursor_info = &#123;1, 0&#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);&#125;int main()&#123; HideCursor(); ... ... return 0;&#125; 結果看起來多麼舒適~ 移動的部分目前就先告一段落ㄌ"},{"title":"貪食蛇-前言","path":"2022/03/05/貪食蛇-前言/","text":"貪食蛇是一個歷史悠久的遊戲，遊戲內容大概就是有一隻蛇會在畫面上移動，如果吃到食物就會變長，移動速度好像也會隨著長度增加而遞減(吧?)。 撞到自己的身體或是牆壁遊戲就結束了。 聽起來是個糞Game，但是，聽說我的計算機程式語言課程要我們使用C++實作一個出來，突然就有趣起來了。 接下來會把我的製作(bug)過程，或是一些遇到的問題紀錄在此網站，敬請期待~"},{"title":"e537: 00455 - Periodic Strings","path":"2022/02/20/e537-00455/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=e537 內容如果一個字串可以通過將另一個長度為k的字串的一個或多個重複連接起來而形成，則它被稱為period k。例如，字串”abcabcabcabc”具有period 3，因為它由字串”abc”的4個重複組成。它還具有period 6 (兩個重複的”abcabc”)和period 12 (一個重複的”abcabcabcabc”)。 輸入第一列有一個整數 N 代表測資數，每筆測資第一列為一個空白，第二列為字串 s (s長度 &lt;= 80)。 輸出最小的 period，兩個連續輸出由空白列分開。 範例輸入1 HoHoHo 範例輸出2 想法可能的解為字串長度的因數，因此只要取因數由小到大判斷是否成立即可。 若長度為1就直接輸出1。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, len, ans; string s; bool suc; cin &gt;&gt; N; while(N--)&#123; cin &gt;&gt; s; len = s.length(); if(len == 1)&#123; cout &lt;&lt; &quot;1\\n&quot;; if(N != 0) cout &lt;&lt; &quot;\\n&quot;; continue; &#125; for(int c = 1; c &lt;= len/2; ++c)&#123; suc = true; if(!(len % c))&#123; for(int i = 0; i &lt; c; ++i)&#123; for(int j = i; j &lt; len; j += c)&#123; if(s[i] != s[j])&#123; suc = false; break; &#125; &#125; if(!suc) break; &#125; if(suc)&#123; cout &lt;&lt; c &lt;&lt; &quot;\\n&quot;; break; &#125; &#125; if(c == len/2) cout &lt;&lt; len &lt;&lt; &quot;\\n&quot;; &#125; if(N != 0) cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"c114: 00409 - Excuses, Excuses!","path":"2022/02/19/c114-00409/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=c114 內容給定多個關鍵字以及若干字串，求出包含最多關鍵字的字串。 每筆測資第一列第一個數字 K (1 &lt;= K &lt;= 20) 代表關鍵字數量，第二個數字 E (1 &lt;= E &lt;= 20) 代表字串數量。接著為關鍵字和字串。 範例輸入5 3dogatehomeworkcanarydiedMy dog ate my homework.Can you believe my dog died after eating my canary… AND MY HOMEWORK?This excuse is so good that it contain 0 keywords.6 5superhighwaycrazythermonuclearbedroomwarbuildingI am having a superhighway built in my bedroom.I am actually crazy.1234567890…..,,,,,0987654321?????!!!!!!There was a thermonuclear war!I ate my dog, my canary, and my homework … note outdated keywords? 範例輸出Excuse Set #1Can you believe my dog died after eating my canary… AND MY HOMEWORK? Excuse Set #2I am having a superhighway built in my bedroom.There was a thermonuclear war! 想法先將字串中非英文字母的字元轉成空白，英文字母則轉成小寫，利用 stringstream 將字串內的單字一個一個抓出來跟關鍵字比對，並記錄次數，最後輸出最多關鍵字的字串即可。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int K, E, mxn, time[20], c = 0; string key[20], s[20], temp, s1; stringstream ss; while(cin &gt;&gt; K &gt;&gt; E)&#123; mxn = -50; memset(time, 0, sizeof(time)); for(int i = 0; i &lt; K; ++i) cin &gt;&gt; key[i] &gt;&gt; ws; for(int i = 0; i &lt; E; ++i)&#123; getline(cin, s[i]); s1 = s[i]; for(int j = 0; j &lt; s1.length(); ++j)&#123; if(isalpha(s1[j]))&#123; if(isupper(s1[j]))&#123; s1[j] = tolower(s1[j]); &#125; &#125; else &#123; s1[j] = &#x27; &#x27;; &#125; &#125; ss &lt;&lt; s1; while(ss &gt;&gt; temp)&#123; for(int j = 0; j &lt; K; ++j)&#123; if(temp == key[j])&#123; ++time[i]; break; &#125; &#125; &#125; mxn = max(time[i], mxn); ss.str(&quot;&quot;), ss.clear(); &#125; cout &lt;&lt; &quot;Excuse Set #&quot; &lt;&lt; ++c &lt;&lt; &quot;\\n&quot;; for(int i = 0; i &lt; K; ++i)&#123; if(time[i] == mxn)&#123; cout &lt;&lt; s[i] &lt;&lt; &quot;\\n&quot;; &#125; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"e543: 00401 - Palindromes","path":"2022/02/18/e543-00401/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=e543 內容鏡像字串是一種字串，當該字串的每個元素更改為鏡像(如果它具有鏡像)並且從右到左讀取該字串時，其結果與從左到右讀取原始字串相同。例如，”3AIAE”是鏡像字符串，因為”A”的鏡像和”I”的鏡像是他們自己，而”3”和”E”為彼此的鏡像。鏡像迴文是指符合迴文字串標準和鏡像字串標準的字串。例如，”ATOYOTA”是一個鏡像迴文，”A”、”T”、”O”、”Y”為彼此的鏡像。 以下為有效字元鏡像對應表： 字元 鏡像 字元 鏡像 字元 鏡像 字元 鏡像 A A J L S 2 1 1 B K T T 2 S C L J U U 3 E D M M V V 4 E 3 N W W 5 Z F O O X X 6 G P Y Y 7 H H Q Z 5 8 8 I I R 0 0 9 請注意，”0”(零)和”O”(字母)被視為相同字符，因此只有字母”O”是有效字符。 輸入每列有一個字串 s (1 &lt;= s長度 &lt;= 20)。 對於每個輸入字串，按照以下輸出此字串屬於鏡像迴文輸出”s – is a mirrored palindrome.”此字串屬於鏡像字串輸出”s – is a mirrored string.”此字串屬於迴文字串輸出”s – is a regular palindrome.”此字串甚麼都不是輸出”s – is not a palindrome.”其中s代表原始字串 此外，在每行輸出之後，需要再輸出換行。 範例輸入NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA 範例輸出NOTAPALINDROME – is not a palindrome. ISAPALINILAPASI – is a regular palindrome. 2A3MEAS – is a mirrored string. ATOYOTA – is a mirrored palindrome. 想法開局先用 map 將字元和其對應的鏡像字元配對起來。 接著就可以分別從字串的左邊以及右邊開始掃，判斷兩點是否一樣，是否為鏡像關係。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; map&lt;char, char&gt; mp; mp[&#x27;A&#x27;] = &#x27;A&#x27;, mp[&#x27;E&#x27;] = &#x27;3&#x27;, mp[&#x27;H&#x27;] = &#x27;H&#x27;, mp[&#x27;I&#x27;] = &#x27;I&#x27;, mp[&#x27;J&#x27;] = &#x27;L&#x27;, mp[&#x27;M&#x27;] = &#x27;M&#x27;, mp[&#x27;O&#x27;] = &#x27;O&#x27;; mp[&#x27;S&#x27;] = &#x27;2&#x27;, mp[&#x27;T&#x27;] = &#x27;T&#x27;, mp[&#x27;U&#x27;] = &#x27;U&#x27;, mp[&#x27;V&#x27;] = &#x27;V&#x27;, mp[&#x27;W&#x27;] = &#x27;W&#x27;, mp[&#x27;X&#x27;] = &#x27;X&#x27;, mp[&#x27;Y&#x27;] = &#x27;Y&#x27;, mp[&#x27;Z&#x27;] = &#x27;5&#x27;, mp[&#x27;0&#x27;] = &#x27;0&#x27;; mp[&#x27;1&#x27;] = &#x27;1&#x27;, mp[&#x27;2&#x27;] = &#x27;S&#x27;, mp[&#x27;3&#x27;] = &#x27;E&#x27;, mp[&#x27;5&#x27;] = &#x27;Z&#x27;, mp[&#x27;8&#x27;] = &#x27;8&#x27;, mp[&#x27;L&#x27;] = &#x27;J&#x27;; string s; int L, R; bool mstr, rpal; while(cin &gt;&gt; s)&#123; L = 0, R = s.length()-1; mstr = rpal = true; while(L &lt; R)&#123; if(s[L] != s[R])&#123; rpal = false; &#125; if(s[L] != mp[s[R]])&#123; mstr = false; &#125; ++L, --R; &#125; cout &lt;&lt; s &lt;&lt; &quot; -- is &quot;; if(mstr &amp;&amp; rpal)&#123; cout &lt;&lt; &quot;a mirrored palindrome.\\n&quot;; &#125; else if(mstr)&#123; cout &lt;&lt; &quot;a mirrored string.\\n&quot;; &#125; else if(rpal)&#123; cout &lt;&lt; &quot;a regular palindrome.\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;not a palindrome.\\n&quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"c032: 00382 - Perfection","path":"2022/02/17/c032-00382/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=c032 內容若一數其因數和(不含自己)等於此數，則為 Perfect Number。6 = 1 + 2 + 3，28 = 1 + 2 + 4 + 7 + 14。若小於則為 deficient，大於則為 abundant。 有一連串(不超過100個)正整數 n (1 &lt;= n &lt;= 60000)，判斷此數是 perfect, deficient 或著 abunddant。 n = 0 結束。 輸出時數字部分佔5個字元長度，靠右對齊。與後方的敘述間空2個空白格。 範例輸入15 28 6 56 60000 22 496 0 範例輸出PERFECTION OUTPUT 15 DEFICIENT 28 PERFECT 6 PERFECT 56 ABUNDANT60000 ABUNDANT 22 DEFICIENT 496 PERFECTEND OF OUTPUT 想法由於數字數量很少(不超過100個)，因此讀取的時候計算就好了。 開一變數紀錄因數和，接著用一迴圈從1跑到n-1，若整除則加進變數。 最後可用 setw() 對齊。 程式碼 C++ 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, sum; cout &lt;&lt; &quot;PERFECTION OUTPUT\\n&quot;; while(cin &gt;&gt; n)&#123; if(n == 0)&#123; cout &lt;&lt; &quot;END OF OUTPUT\\n&quot;; break; &#125; sum = 0; for(int i = 1; i &lt; n; ++i)&#123; if(!(n % i)) sum += i; &#125; cout &lt;&lt; setw(5) &lt;&lt; n &lt;&lt; &quot; &quot;; if(sum == n) cout &lt;&lt; &quot;PERFECT\\n&quot;; else if(sum &lt; n) cout &lt;&lt; &quot;DEFICIENT\\n&quot;; else cout &lt;&lt; &quot;ABUNDANT\\n&quot;; &#125; return 0;&#125;"},{"title":"c108: 00305 - Joseph","path":"2022/02/16/c108-00305/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=c108 內容一群人圍成一個圈圈(編號從1, 2, 3, …, n)，然後開始數，第 m 個人要被吃掉(第一次從編號1的人開始數)。 現在假設共有2k個人，其中排在編號 1 到 k 的是好人，排在編號 k+1 到 2k 的是壞人，你的任務就是要找出一個最小的 m，使得在所有 k 個壞人被吃掉之前，沒有一個好人會被吃掉。 每一列有一個整數 k (0 &lt; k &lt; 14)。k = 0 結束。 範例輸入340 範例輸出530 想法枚舉所有可能的 m 值，觀察後發現m &gt; k (否則第一輪就取到好人)。(m-1) % 2*k &gt;= k (一樣看第一輪)。 如果上述兩條件成立，就可以開始取人了，取到好人就直接跳掉，接著判斷下一個 m。 可在一開始使用一個陣列儲存所有 k 對應的 m ，詢問時就可直接印出。 參考資料:YUI HUANG 演算法學習筆記， inversion的小屋 程式碼 C++ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int m, kill, ans[14], total; bool suc; for(int i = 1; i &lt; 14; ++i)&#123; suc = false; m = i; total = i &lt;&lt; 1; while(!suc)&#123; ++m; if(i == 1) suc = true; if((m-1)%total &gt;= i)&#123; kill = (m-1) % total; for(int c = 2; c &lt;= i; ++c)&#123; kill = (kill+m-1) % (total-c+1); if(kill &lt; i) break; if(c == i) suc = true; &#125; &#125; &#125; ans[i] = m; &#125; int k; while(cin &gt;&gt; k &amp;&amp; k)&#123; cout &lt;&lt; ans[k] &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"c031: 00264 - Count on Cantor","path":"2022/02/15/c031-00264/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=c031 內容現代數學中有一個有名的證明（由Georg Cantor所提出的）：有理數是可數的。他使用一個圖表（Cantor’s 列舉）列舉出有理數，如下圖所示：在此圖中，第一項是1/1,第二項是1/2,第三項是2/1,第四項是3/1,第五項是2/2,以下依此類推。 每筆資料一列，有一個整數 n (1 &lt;= n &lt;= 10^7)，輸出在Cantor’s 列舉圖中的第n項。 範例輸入3147 範例輸出TERM 3 IS 2/1TERM 14 IS 2/4TERM 7 IS 1/4 想法 1 2 6 7 15 3 5 8 14 4 9 1310 1211 可以從 1, 3, 6, 10, 15, 21 …，這個數列來看，找出第一個大於 n 的數，看此數在數列中是奇數項還是偶數項，就可以進行運算，求出在圖表中的值。 假設 n = 14發現數列中第一個大於 n 的數為 15 為第五項(奇數)，設為 sum已知 15 在圖表中的值為 1/5設 c = 5(第五項)1+sum-n / c-sum+n = 1+15-14 / 5-15+14 = 2/4得到 n 在圖表中的值為 2/4 # 若是偶數項，則公式為c-sum+n / 1+sum-n 程式碼 C++ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, sum, c; while(cin &gt;&gt; n)&#123; sum = c = 0; while(sum &lt; n)&#123; ++c; sum += c; &#125; if(c &amp; 1)&#123; cout &lt;&lt; &quot;TERM &quot; &lt;&lt; n &lt;&lt; &quot; IS &quot; &lt;&lt; 1+sum-n &lt;&lt; &quot;/&quot; &lt;&lt; c-sum+n &lt;&lt; &quot;\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;TERM &quot; &lt;&lt; n &lt;&lt; &quot; IS &quot; &lt;&lt; c-sum+n &lt;&lt; &quot;/&quot; &lt;&lt; 1+sum-n &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;"},{"title":"d182: 00256 - Quirksome Squares","path":"2022/02/14/d182-00256/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=d182 內容把一數從中間切開，若左右兩數相加的平方剛好等於原本的數，則此數稱為 quirksome number。 3025 = (30+25)^2 給定一數 N 代表位數，找出符合以上性質的所有數。 像是4位數就是從0000到9999。注意：數字前方的0也要算在內。也就是說0001等於 (00+01)^2 ，是一個4位數的quirksome number。 每筆測資有一個 N (N = 2, 4, 6, 8)。 範例輸入22 範例輸出000181000181 想法此數必定為完全平方數，如果 N = 6，就只要判斷000 ~ 999 就好，判斷方式如下假設迴圈跑到 703得到其平方 493209做除法運算與取餘數可得到左右兩數493209 / 1000 = 493493209 % 1000 = 209將兩數相加平方看是否等於原平方數。 把得到的值利用佇列(queue)或陣列先存起來，當 N 輸入時再進行調用即可。 用此方法 000001 會存成 1 ，輸出時要補 0，可將數字從 int 轉成 string 型態，利用長度判斷需要補幾個 0 。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; queue&lt;int&gt; two, four, six, eight; int temp, compare; for(int i = 0; i &lt; 10; ++i)&#123; temp = i*i; compare = temp/10 + temp%10; compare *= compare; if(compare == temp)&#123; two.push(temp); &#125; &#125; for(int i = 0; i &lt; 100; ++i)&#123; temp = i*i; compare = temp/100 + temp%100; compare *= compare; if(compare == temp)&#123; four.push(temp); &#125; &#125; for(int i = 0; i &lt; 1000; ++i)&#123; temp = i*i; compare = temp/1000 + temp%1000; compare *= compare; if(compare == temp)&#123; six.push(temp); &#125; &#125; for(int i = 0; i &lt; 10000; ++i)&#123; temp = i*i; compare = temp/10000 + temp%10000; compare *= compare; if(compare == temp)&#123; eight.push(temp); &#125; &#125; int n; string s; while(cin &gt;&gt; n)&#123; if(n == 2)&#123; int two_size = two.size(); for(int i = 0; i &lt; two_size; ++i)&#123; two.push(two.front()); s = to_string(two.front()); if(s.length() &lt; 2)&#123; for(int i = 0; i &lt; 2-s.length(); ++i) cout &lt;&lt; 0; &#125; cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; two.pop(); &#125; &#125; else if(n == 4)&#123; int four_size = four.size(); for(int i = 0; i &lt; four_size; ++i)&#123; four.push(four.front()); s = to_string(four.front()); if(s.length() &lt; 4)&#123; for(int i = 0; i &lt; 4-s.length(); ++i) cout &lt;&lt; 0; &#125; cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; four.pop(); &#125; &#125; else if(n == 6)&#123; int six_size = six.size(); for(int i = 0; i &lt; six_size; ++i)&#123; six.push(six.front()); s = to_string(six.front()); if(s.length() &lt; 6)&#123; for(int i = 0; i &lt; 6-s.length(); ++i) cout &lt;&lt; 0; &#125; cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; six.pop(); &#125; &#125; else &#123; int eight_size = eight.size(); for(int i = 0; i &lt; eight_size; ++i)&#123; eight.push(eight.front()); s = to_string(eight.front()); if(s.length() &lt; 8)&#123; for(int i = 0; i &lt; 8-s.length(); ++i) cout &lt;&lt; 0; &#125; cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; eight.pop(); &#125; &#125; &#125; return 0;&#125;"},{"title":"d089: 00145 - Gondwanaland Telecom","path":"2022/02/13/d089-00145/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=d089 內容Gondwanaland Telecom這家電話公司收費的標準是以所撥電話的距離及時段來訂定的，如下表。在這裡charging step就是指不同的距離。 Charging Step Day Rate Evening Rate Night Rate A 0.10 0.06 0.02 B 0.25 0.15 0.05 C 0.53 0.33 0.13 D 0.87 0.47 0.17 E 1.44 0.80 0.30 Day Rate = 8am to 6pmEvening Rate = 6pm to 10pmNight Rate = 10pm to 8am 所有的收費是根據該通電話每一分鐘多少錢來計算的，所以若有某通電話有跨時段，則按時段不同的收費標準分別計算在加總。例如：有一通電話從5:58pm開始到6:04pm結束，那前2分鐘是按白天（Day）的標準計費，而後4分鐘則按傍晚（Evening）的標準計費。 所有小於一分鐘的電話不列入計費，而且沒有一通電話會持續超過24小時。 每筆測資一列，分別代表 charging step(A~Z)、電話號碼、開始時間、結束時間。輸入 # 代表結束。 輸出電話號碼、各時段通話分鐘數、charging step、總花費。各部分輸出於一定位置，以靠右對齊來說，分別在10,16,22,28,31,39的位置。 範例輸入C 765-7457 10 41 04 29B 207-0225 21 28 07 53B 316-0414 16 43 09 37C 463-1401 19 28 00 33D 514-9373 01 20 09 08# 範例輸出765-7457 439 240 389 C 362.44 207-0225 0 32 593 B 34.45 316-0414 174 240 600 B 109.50 463-1401 0 152 153 C 70.05 514-9373 68 0 400 D 127.16 想法先將計費表用 map 儲存，並把時間分成如下7個部分，把每一部分的結束時間以陣列儲存。0:00 ~ 8:008:00 ~ 18:0018:00 ~ 22:0022:00 ~ 8:00 (隔天)8:00 ~ 18:0018:00 ~ 22:0022:00 ~ 24:00 將時間轉換成分鐘方便計算，若通話結束時間小於通話開始時間，則代表跨夜，需將其加上24小時(若兩者相等以通話24小時計算，不然UVA會WA)。 另開一陣列紀錄各個時間區間的通話分鐘數，接著就可以開始遍歷剛剛建立的儲存各個結束時間的陣列，判斷通話開始時間是否與結束時間在同一區間，若否，則紀錄此區間通話分鐘數，並更新通話開始時間為此區間結束時間。過程中可順便計算花費(通話分鐘數*計費表對應的價錢)。 最後將各區間通話分鐘數依照 Day, Evening, Night 區分即可。 輸出時可用 setw() 調整對齊。 參考資料:YUI HUANG 演算法學習筆記 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; map&lt;char, vector&lt;double&gt;&gt; mp; mp[&#x27;A&#x27;] = &#123;0.02, 0.10, 0.06, 0.02, 0.10, 0.06, 0.02&#125;; mp[&#x27;B&#x27;] = &#123;0.05, 0.25, 0.15, 0.05, 0.25, 0.15, 0.05&#125;; mp[&#x27;C&#x27;] = &#123;0.13, 0.53, 0.33, 0.13, 0.53, 0.33, 0.13&#125;; mp[&#x27;D&#x27;] = &#123;0.17, 0.87, 0.47, 0.17, 0.87, 0.47, 0.17&#125;; mp[&#x27;E&#x27;] = &#123;0.30, 1.44, 0.80, 0.30, 1.44, 0.80, 0.30&#125;; int time[] = &#123;480, 1080, 1320, 1920, 2520, 2760, 2880&#125;; char step; string phone_number; int hour1, min1, hour2, min2, sum1, sum2, Day, Evening, Night; double cost[7], total; while(cin &gt;&gt; step)&#123; if(step == &#x27;#&#x27;) break; memset(cost, 0, sizeof(cost)); cin &gt;&gt; phone_number &gt;&gt; hour1 &gt;&gt; min1 &gt;&gt; hour2 &gt;&gt; min2; sum1 = hour1*60 + min1, sum2 = hour2*60 + min2; if(sum1 &gt;= sum2) sum2 += 24*60; Day = Evening = Night = total = 0; for(int i = 0; i &lt; 7; ++i)&#123; if(sum1 &lt;= time[i])&#123; if(sum2 &lt;= time[i])&#123; cost[i] = sum2 - sum1; total += cost[i] * mp[step][i]; break; &#125; else &#123; cost[i] = time[i] - sum1; total += cost[i] * mp[step][i]; sum1 = time[i]; &#125; &#125; &#125; Day = cost[1] + cost[4]; Evening = cost[2] + cost[5]; Night = cost[0] + cost[3] + cost[6]; cout &lt;&lt; setw(10) &lt;&lt; phone_number; cout &lt;&lt; setw(6) &lt;&lt; Day &lt;&lt; setw(6) &lt;&lt; Evening &lt;&lt; setw(6) &lt;&lt; Night &lt;&lt; setw(3) &lt;&lt; step; cout &lt;&lt; setw(8) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; total &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"","path":"2022/02/12/2022-2-12-隨筆/","text":"總算把剩下那四題 zerojudge 沒有的CPE 一顆星選集 49 道必考題給補完ㄌ。所以，總共49題，一題不漏全部結束了，可喜可賀ㄚ。 雖然這是一顆星，但可不是鬧著玩的，有些題目用到的一些數學公式我早就忘記了，像是e510: 10056 - What is the Probability?，那題我真的不知道在幹嘛，直接 google 找答案，才知道跟無窮等比數列有關。 還有一些題目用特定的資料結構解會比較輕鬆，像是 stack、queue、map、set，他們獨有的一些特性都蠻好用的。 所以如果數學公式都還記得，這些資料結構也會使用，那這 49 題應該就沒什麼問題ㄌ。"},{"title":"UVA-11005: Cheapest Base","path":"2022/02/12/UVA-11005/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1946 內容數字可以被表示成不同的進位制，當我們把數字表示成n進位時（2 &lt;= n &lt;= 36），我們需要用到字串’0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ’的前 n 項。 每個字元有自己的價錢，以一個1~128的整數表示，計算用哪些進位來表示最省錢。 輸入第一列 T (T &lt;= 25) 代表測資數，每筆測資前四列代表各個字元的價錢(一列9個)，接著有一整數 Q 代表數字數量，隨後為數字。 範例輸入210 8 12 13 15 13 13 16 911 18 24 21 23 23 23 13 1517 33 21 23 27 26 27 19 422 18 30 30 24 16 26 21 2159832992112345800348148736451 1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 140110100 範例輸出Case 1:Cheapest base(s) for number 98329921: 24Cheapest base(s) for number 12345: 13 31Cheapest base(s) for number 800348: 31Cheapest base(s) for number 14: 13Cheapest base(s) for number 873645: 22 Case 2:Cheapest base(s) for number 0: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1819 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36Cheapest base(s) for number 1: 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1819 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36Cheapest base(s) for number 10: 11 12 13 14 15 16 17 18 19 20 21 22 23 2425 26 27 28 29 30 31 32 33 34 35 36Cheapest base(s) for number 100: 11 12 13 14 15 16 17 18 19 20 21 22 23 2425 26 27 28 29 30 31 32 33 34 35 36 想法對於每個數字，枚舉出各個進位表示的花費，並存到陣列，找出最小值，最後遍歷一次陣列，若等於最小值就輸出。 最後一筆測資後面不要有換行。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int T, mp[36], Q, n, value[37]; cin &gt;&gt; T; for(int c = 1; c &lt;= T; ++c)&#123; for(int i = 0; i &lt; 36; ++i) cin &gt;&gt; mp[i]; cin &gt;&gt; Q; cout &lt;&lt; &quot;Case &quot; &lt;&lt; c &lt;&lt; &quot;:\\n&quot;; while(Q--)&#123; cin &gt;&gt; n; int mi = INT_MAX; for(int base = 2; base &lt;= 36; ++base)&#123; int temp = n, sum = 0; while(temp &gt; 0)&#123; sum += mp[temp%base]; temp /= base; &#125; mi = min(mi, sum); value[base] = sum; &#125; cout &lt;&lt; &quot;Cheapest base(s) for number &quot; &lt;&lt; n &lt;&lt; &quot;:&quot;; for(int i = 2; i &lt;= 36; ++i)&#123; if(value[i] == mi)&#123; cout &lt;&lt; &quot; &quot; &lt;&lt; i; &#125; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; if(c != T) cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"UVA-10642: Can You Solve It?","path":"2022/02/12/UVA-10642/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1583 內容給定兩座標(y, x)，求出從一點走到另一點所需的步數。 輸入第一列 n (0 &lt; n &lt;= 500) 代表測資數，接著為兩點座標(0 &lt;= y, x &lt;= 100000)。 範例輸入30 0 0 10 0 1 00 0 0 2 範例輸出Case 1: 1Case 2: 2Case 3: 3 想法觀察後發現，如果從 (0, 0) 開始，到(0, x) 的步數為到 (0, 1) = 1到 (0, 2) = 3到 (0, 3) = 6到 (0, 4) = 10 因此可以先將 y = 0 的點到 (0, 0) 的步數用陣列存起來 12mp[0] = 0;for(int i = 1; i &lt; 100001; ++i) mp[i] = mp[i-1] + i; 接著繼續觀察後發現，可以按照 y + x 的值來分組y + x = 1(0, 1) = 1(1, 0) = 2 y + x = 2(0, 2) = 3(1, 1) = 4(2, 0) = 5 y + x = 3(0, 3) = 6(1, 2) = 7(2, 1) = 8(3, 0) = 9 經由上述觀察，可以先找出此座標的組別(y + x 的值)，接著利用已知的(0, x)步數 + 座標的 y 值，得到此座標到原點的步數，兩座標到原點的步數相減即為所求。 程式碼 C++ 1234567891011121314151617#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, y1, x1, y2, x2, mp[100001]; mp[0] = 0; for(int i = 1; i &lt; 100001; ++i) mp[i] = mp[i-1] + i; cin &gt;&gt; n; for(int c = 1; c &lt;= n; ++c)&#123; cin &gt;&gt; y1 &gt;&gt; x1 &gt;&gt; y2 &gt;&gt; x2; int step1 = mp[y1+x1] + y1, step2 = mp[y2+x2] + y2; cout &lt;&lt; &quot;Case &quot; &lt;&lt; c &lt;&lt; &quot;: &quot; &lt;&lt; step2 - step1 &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"UVA-10221: Satellites","path":"2022/02/11/UVA-10221/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1162 內容給定地球半徑 6440 km，地球表面到衛星距離 s ，夾角 a (可能為 min 或 deg)，求出兩衛星的距離(弧長，直線距離)。 每筆測資一列，分別為 s、a、(min or deg)。 範例輸入500 30 deg700 60 min200 45 deg 範例輸出3633.775503 3592.408346124.616509 124.6149275215.043805 5082.035982 想法deg = min / 60。角度超過 180 要拿 360 去減。pi = 2.0*acos(0.0)。弧長 = 2*pi*R*角度/360。直線距離可用正弦定理或餘弦定理求出(我不知道我的正弦出了什麼Bug，一直WA = =)。 sin(), cos() 傳入的是弧度。最後用 setprecision() 控制小數點位數。 程式碼 C++ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; double dis, a, arc, chord; string s; double pi = 2.0*acos(0.0); double r = 6440.0; while(cin &gt;&gt; dis &gt;&gt; a &gt;&gt; s)&#123; if(s == &quot;min&quot;) a /= 60.0; if(a &gt; 180.0) a = 360.0 - a; arc = 2.0*pi*(r+dis)*a/360.0; double R = r+dis; //chord = sin(a*pi/180.0)*(r+dis) / sin(((180.0-a)/2.0)*pi/180.0); chord = sqrt(R*R + R*R - 2.0*R*R*cos(a*pi/180.0)); cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; arc &lt;&lt; &quot; &quot; &lt;&lt; chord &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"UVA-10093: An Easy Problem!","path":"2022/02/09/UVA-10093/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://vjudge.net/problem/UVA-10093 內容給定一個 N (2 &lt;= N &lt;= 62)進位整數 R (R &lt;= 10^1000)，保證R一定可以用(N-1)除的盡，找出最小的 N。在本問題中，62進位數字系統的符號為（0..9，A..Z，a..z）。類似的，61進位數字系統的符號為（0..9，A..Z，a..y）。依此類推，2進位數字系統的符號為（0..1）。 如果找不到，輸出’such number is impossible!’。 範例輸入3 +5-A4964654623232355454546554546546545464564564565465465454654600655460 -005444554f546554654A544565646600000q12310q12345 範例輸出461162605922such number is impossible! 想法如果此數為abc，可以看成a*N^2 + b*N^1 + c= a*N*(N-1 + 1) + b*(N-1 + 1) + c= a*N*(N-1) + a*N*1 + b*(N-1) + b*1 + c= a*N*(N-1) + a*(N-1 + 1) + b*(N-1) + b + c= a*N*(N-1) + a*(N-1) + a*1 + b*(N-1) + b + c= (a*N + a + b)*(N-1) + (a + b + c) # 可以發現，若此數是 (N-1) 的倍數，則 (a + b + c) 必定有一因數 (N-1)，所以只要計算各個位數之和，再去判斷是否有數能使其整除即可。 使用 getline 一次讀取一列，接著依序判斷，若不是62進位數字系統的符號（0..9，A..Z，a..z），直接無視。可用 isdigit(), isupper(), islower()判斷是否為數字、大寫字母、小寫字母。 最後尋找 N-1 時，從各個位數之最大值開始找，像是 48763 就從 8 開始判斷，因為 N &lt;= 8 是不合理的。 若和為 0 直接輸出 2(N的最小值)，避免出現錯誤。 參考資料:YUI HUANG 演算法學習筆記 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string s; int sum, mxn, temp; bool suc; while(getline(cin, s))&#123; sum = 0, mxn = -50, suc = false; for(int i = 0; i &lt; s.length(); ++i)&#123; if(isdigit(s[i])) temp = s[i]-&#x27;0&#x27;; else if(isupper(s[i])) temp = (s[i]-&#x27;A&#x27;)+10; else if(islower(s[i])) temp = (s[i]-&#x27;a&#x27;)+36; else continue; mxn = max(mxn, temp); sum += temp; &#125; if(sum == 0)&#123; cout &lt;&lt; &quot;2\\n&quot;; continue; &#125; for(int i = mxn; i &lt; 62; ++i)&#123; if(!(sum%i))&#123; cout &lt;&lt; i+1 &lt;&lt; &quot;\\n&quot;; suc = true; break; &#125; &#125; if(!suc) cout &lt;&lt; &quot;such number is impossible!\\n&quot;; &#125; return 0;&#125;"},{"title":"d129: 00136 - Ugly Numbers","path":"2022/02/09/d129-00136/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=d129 內容Ugly Number的定義為：該數之質因數必須為 2, 3 或 5當然了，依照慣例，1 也算是 Ugly Number。在此列舉一串數列：1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15這些就是前 11 個 Ugly Numbers。請寫一個程式求出第1500個Ugly Number。 範例輸入No input 範例輸出The 1500’th ugly number is . 想法依序拿每個已知的 Ugly Number 去乘上2, 3, 5產生新的 Ugly Number。 從1開始，得到2, 3, 5，此時已知為1, 2, 3, 5。接著拿2來乘，得到4, 6, 10，此時已知為1, 2, 3, 4, 5, 6, 10。接著拿3，得到6, 9, 15，此時已知為1, 2, 3, 4, 5, 6, 9, 10, 15。接著拿4，得到8, 12, 20，此時已知為1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 20。以此類推，直到產生第1500個 Ugly Number。 但是可能會遇到產生數字重覆的情況，像是拿2跟拿3來乘，6重複了。以及數字大小順序問題，像是4產生的8比3產生的9, 15 還小。 此時可以運用 set 特性，不重複儲存相同的數，以及默認由小到大排列，即可解決問題。 使用 begin() 函數得到 set 內第一個元素，產生完新的數後可直接用 erase() 刪除，使得下一次使用 begin() 時為下一個數，紀錄刪了幾個數即可。 C++ STL: Set 程式碼 C++ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int num[] = &#123;2, 3, 5&#125;, c = 0; set&lt;long long&gt; myset; long long temp; myset.insert(1); while(c &lt; 1500)&#123; auto it = myset.begin(); temp = *it; for(int i = 0; i &lt; 3; ++i)&#123; myset.insert(temp*num[i]); &#125; myset.erase(temp); ++c; &#125; cout &lt;&lt; &quot;The 1500&#x27;th ugly number is &quot; &lt;&lt; temp &lt;&lt; &quot;.\\n&quot;; return 0;&#125;"},{"title":"d206: 00108 - Maximum Sum","path":"2022/02/08/d206-00108/","text":"CPE 一顆星(騙人的吧) 題目連結:https://zerojudge.tw/ShowProblem?problemid=d206 內容給你一個 N*N 的陣列，請你找出有最大和的子區域 (sub-rectangle)其和為多少。一個區域的和指的是該區域中所有元素值的和。一個區域是指相連的任意大小的子陣列。範例： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子區域： 9 2 -4 1 -1 8 →15 每筆測資第一列 N (N &lt;= 100)，接著有 N*N 個數字代表此陣列，EOF結束。輸入很醜，但是C/C++沒差。 範例輸入40 -2 -7 0 9 2-6 2 -41 -4 1 -1 8 0-2 10 9 116 24 -121 30 14 2 119 122 28 -53 125 -71 87 -57 42 -111 125-33 91 -121 30 -28 1 -16 97 -11 68 -24 103 -126 98 -61 33 48 109-88 67 -72 77 -107 95 -78 23 -86 45 -4 28 -121 73 -57 20 -122 968 -97 79 -68 122 -42 88 -22 0 -116 55 -44 68 -109 43 -32 103 -54122 -41 62 -114 113 -32 29 -22 99 -11 38 -60 88 -83 28 -83 122 -56100 -86 63 -49 111 -77 91 -88 69 -110 範例輸出15963 想法把陣列分成 N*j 來看(j為1~N)像是4*4陣列0 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2將其拆成4*1 09-4-1 -2218 -7-6-40 021-2 4*2 0 -29 2-4 1-1 8 -2 -72 -61 -48 0 -7 0-6 2-4 10 -2 4*3，4*4 同上方法。 並合併成一維數列像是-7 0-6 2-4 10 -2變成-7-4-3-2之後分別計算這些子陣列的最大連續子序列(一數列的最大區間和)，最大值即為所求。 為了方便操作，若輸入為0 -2 -7 09 2 -6 2-4 1 -4 1-1 8 0 -2可以將其儲存成0 0 0 0 00 0 -2 -9 -90 9 11 5 70 -4 -3 -7 -60 -1 7 7 5那麼 12for(int i = 0; i &lt; 4; ++i) for(int j = i+1; j &lt;= 4; ++j) 把 i, j 當行來看(直的)，就可以將上面所有的一維數列都考慮進去，裡面再加一個迴圈進行最大連續子序列運算即可。 程式碼 C++ 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, dp[105][105]; while(cin &gt;&gt; N)&#123; memset(dp, 0, sizeof(0)); for(int i = 1; i &lt;= N; ++i)&#123; for(int j = 1; j &lt;= N; ++j)&#123; cin &gt;&gt; dp[i][j]; dp[i][j] += dp[i][j-1]; &#125; &#125; int mxn = INT_MIN, count; for(int i = 0; i &lt; N; ++i)&#123; for(int j = i+1; j &lt;= N; ++j)&#123; count = 0; for(int k = 1; k &lt;= N; ++k)&#123; count = max(count+dp[k][j]-dp[k][i], dp[k][j]-dp[k][i]); mxn = max(mxn, count); if(count &lt; 0) count = 0; &#125; &#125; &#125; cout &lt;&lt; mxn &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125; 參考資料:inversion大神的小屋"},{"title":"C++ STL: Set","path":"2022/02/07/集合/","text":"集合 簡介按照特定順序存儲元素，其元素不重覆。 標頭檔1#include &lt;set&gt; 宣告1set&lt;type&gt; myset type 可為 int, char, string…，myset可為任意名字。 常用操作 函數 描述 insert() 插入指定元素 erase() 刪除指定元素 clear() 刪除所有元素 count() 回傳元素是否存在 find() 回傳指向該元素的迭代器 empty() 回傳是否為空 size() 回傳有幾個元素 範例 C++ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; myset; myset.insert(4); //插入元素 myset.insert(8); myset.insert(7); myset.insert(2); cout &lt;&lt; &quot;目前元素個數為 &quot; &lt;&lt; myset.size() &lt;&lt; &quot;\\n&quot;; myset.erase(2); //刪除指定元素 cout &lt;&lt; &quot;此元素是否存在 &quot; &lt;&lt; myset.count(2) &lt;&lt; &quot;\\n&quot;; myset.insert(6), myset.insert(3); myset.insert(8); //8已經存在，此行沒效果 for(auto it = myset.begin(); it != myset.end(); ++it)&#123; //使用迭代器遍歷 cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; myset.clear(); //刪除所有元素 cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; myset.empty() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 輸出 目前元素個數為 4此元素是否存在 03 4 6 7 8是否為空 1 資料來源:cplusplus.com"},{"title":"C++ STL: Map","path":"2022/02/07/映射/","text":"映射 簡介又稱關聯陣列，按照特定順序存儲由鍵值(key)和映射值(value)組合而成的元素，可以想成 key 值允許用其他型態的陣列。 標頭檔1#include &lt;map&gt; 宣告1map&lt;type1, type2&gt; mp; type1, type2 可為 int, char, string…，mp可為任意名字。 常用操作 函數 描述 insert() 插入指定元素 erase() 刪除指定元素 clear() 刪除所有元素 count() 回傳元素是否存在 find() 回傳指向該元素的迭代器 empty() 回傳是否為空 size() 回傳有幾個元素 插入元素分為兩種方法，一種是以陣列方式直接插入，若該 key 值已經存在，則 value 會更新成新的數值。 C++ 1234mp[&quot;kirito&quot;] = 10;mp[&quot;asuna&quot;] = 16;mp[&quot;rem&quot;] = 520;mp[&quot;kirito&quot;] = 48763; //kirito對應的value更新成48763 另一種則是使用 insert() 函數，把 key 值和 value 值包裝成一個 pair 的形式插入。和陣列插入不一樣的是，若該 key 值已經存在，則不插入，回傳一個指向該元素的迭代器。 C++ 1234mp.insert(pair&lt;string, int&gt;(&quot;kirito&quot;, 10));mp.insert(pair&lt;string, int&gt;(&quot;asuna&quot;, 16));mp.insert(pair&lt;string, int&gt;(&quot;rem&quot;, 520));mp.insert(pair&lt;string, int&gt;(&quot;kirito&quot;, 48763)); //沒效果 範例 C++ 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;string, int&gt; mp; mp[&quot;克萊茵&quot;] = 10; mp[&quot;asuna&quot;] = 16; mp.insert(pair&lt;string, int&gt;(&quot;rem&quot;, 520)); mp.insert(pair&lt;string, int&gt;(&quot;桐谷和人&quot;, 48763)); cout &lt;&lt; &quot;目前元素個數為 &quot; &lt;&lt; mp.size() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;此元素的value為 &quot; &lt;&lt; mp.find(&quot;克萊茵&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; //回傳指向該元素的迭代器，並將其指向value mp.erase(&quot;克萊茵&quot;); //刪除指定元素 cout &lt;&lt; &quot;此元素的value為 &quot; &lt;&lt; mp.find(&quot;克萊茵&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; //此元素已被刪除，指向之value為亂數 for(auto it = mp.begin(); it != mp.end(); ++it)&#123; //使用迭代器遍歷，默認排序為字典序 cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; it -&gt; second &lt;&lt; &quot;\\n&quot;; &#125; mp.clear(); //刪除所有元素 cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; mp.empty() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 輸出 目前元素個數為 4此元素的value為 10此元素的value為 17377760asuna 16rem 520桐谷和人 48763是否為空 1 參考資料:cplusplus.com"},{"title":"C++ STL: Queue","path":"2022/02/07/佇列/","text":"佇列 簡介按照先進先出(FIFO, First In First Out)運作，只允許從後端(back)插入(push)，前端(front)移除(pop)。就像排隊一樣，從後面排，先來的先進去。 標頭檔1#include &lt;queue&gt; 宣告1queue&lt;type&gt; q; type 可為 int, char, string…，q可為任意名字。 常用操作 函數 描述 push() 從佇列後端插入一元素 pop() 從佇列前端移除一元素 front() 回傳前端元素 back() 回傳後端元素 empty() 回傳佇列是否為空 size() 回傳佇列中有幾個元素 範例 C++ 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main()&#123; queue&lt;int&gt; q; for(int i = 0; i &lt; 5; ++i) q.push(i); //q內元素為0, 1, 2, 3, 4 q.pop(); //q內元素為1, 2, 3, 4 cout &lt;&lt; &quot;目前元素個數為 &quot; &lt;&lt; q.size() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; q.empty() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;前端元素為 &quot; &lt;&lt; q.front() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;後端元素為 &quot; &lt;&lt; q.back() &lt;&lt; &quot;\\n&quot;; while(!q.empty())&#123; //不斷移除前端元素，直到佇列為空 q.pop(); &#125; cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; q.empty() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 輸出 目前元素個數為 4是否為空 0前端元素為 1後端元素為 4是否為空 1 參考資料:cplusplus.com"},{"title":"C++ STL: Stack","path":"2022/02/07/堆疊/","text":"堆疊 簡介按照後進先出(LIFO, Last In First Out)運作，只允許從容器頂端(top)進行插入(push)和移除(pop)。就像一層一層疊起來的書本，只能從上面放，上面取(不要調皮)。 標頭檔1#include &lt;stack&gt; 宣告1stack&lt;type&gt; sta; type 可為 int, char, string…，sta可為任意名字。 常用操作 函數 描述 push() 從堆疊頂端插入一元素 pop() 從堆疊頂端移除一元素 top() 回傳頂端元素 empty() 回傳堆疊是否為空 size() 回傳堆疊中有幾個元素 範例 C++ 123456789101112131415161718#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; sta; for(int i = 0; i &lt; 5; ++i) sta.push(i); //sta內元素為0, 1, 2, 3, 4 sta.pop(); //移除頂端一元素，sta內元素為0, 1, 2, 3 cout &lt;&lt; &quot;目前頂端元素為 &quot; &lt;&lt; sta.top() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; sta.empty() &lt;&lt; &quot;\\n&quot;; cout &lt;&lt; &quot;目前元素個數為 &quot; &lt;&lt; sta.size() &lt;&lt; &quot;\\n&quot;; while(!sta.empty())&#123; //不斷移除頂端元素，直到堆疊為空 sta.pop(); &#125; cout &lt;&lt; &quot;是否為空 &quot; &lt;&lt; sta.empty() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 輸出 目前頂端元素為 3是否為空 0目前元素個數為 4是否為空 1 參考資料:cplusplus.com"},{"title":"d424: 00105 - The Skyline Problem","path":"2022/02/06/d424-00105/","text":"CPE 一顆星 題目連結:https://zerojudge.tw/ShowProblem?problemid=d424 內容所有的建築物都是矩形的，並且都建築在同一個平面上。給定多棟建築物數據，求出這些建築物的空中輪廓(skyline)。 每列有一棟建築物資料，包含左邊位置 Li 、高度 Hi 、右邊位置 Ri。 所有數字都小於 10000，建築物已按照 Li 排列。 範例輸入1 11 52 6 73 13 912 7 1614 3 2519 18 2223 13 2924 4 28 範例輸出1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0 想法使用一個陣列紀錄該點最大建築物高度，一次讀取一棟建築物，若高於先前建築物，則更新。並紀錄最後一棟建築物的右邊位置。 接著遍歷陣列，若相鄰點高度不同，則輸出位置與高度。 程式碼 C++ 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int Li, Hi, Ri, high[10001], R = -50; memset(high, 0, sizeof(high)); while(cin &gt;&gt; Li &gt;&gt; Hi &gt;&gt;Ri)&#123; for(int i = Li; i &lt; Ri; ++i)&#123; high[i] = max(Hi, high[i]); R = max(Ri, R); &#125; &#125; for(int i = 0; i &lt;= R; ++i)&#123; if(high[i] != 0 &amp;&amp; i == 0)&#123; cout &lt;&lt; &quot;0 &quot; &lt;&lt; high[i] &lt;&lt; &quot; &quot;; &#125; else if(high[i] != high[i+1])&#123; cout &lt;&lt; i+1 &lt;&lt; &quot; &quot; &lt;&lt; high[i+1] &lt;&lt; &quot; &quot;; &#125; &#125; return 0;&#125;"},{"title":"","path":"2022/02/05/2022-2-5-隨筆/","text":"終於刷完CPE 一顆星選集 49 道必考題ㄌ，不過有 4 題 zerojudge 上沒有，所以其實只寫了 45 題，嘿嘿。"},{"title":"f709: 12019 - Doom's Day Algorithm","path":"2022/02/05/f709-12019/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=f709 內容假設年分為 2011。給定日期，求出那天星期幾。 輸入第一列 T (T &lt;= 100)代表測資數，接著有 T 列 月份和星期。 範例輸入91 62 284 55 268 111 112 2512 313 9 範例輸出ThursdayMondayTuesdayThursdayMondayTuesdaySundaySaturdayWednesday 想法使用一個陣列紀錄每個月分別有幾天，再用一個二維陣列紀錄該月該天星期幾，從 1/1 跑到 12/31，過程中更新此二維陣列之數值。像是 week[10][16] = 5 代表 10/16 為星期五。 此陣列存取的資料為整數，需另外用一個字串陣列轉換。 程式碼 C++ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int month[] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int week[13][32], c = 6; string s[] = &#123;&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;&#125;; memset(week, 0, sizeof(week)); for(int i = 1; i &lt;= 12; ++i)&#123; for(int j = 1; j &lt;= month[i-1]; ++j)&#123; week[i][j] = c; c = c%7 + 1; &#125; &#125; int T, M, D, temp; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; M &gt;&gt; D; temp = week[M][D]; cout &lt;&lt; s[temp-1] &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"d186: 11461 - Square Numbers","path":"2022/02/05/d186-11461/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d186 內容給定兩個整數 a, b(0 &lt; a &lt;= b &lt;= 100000)，求出 a, b 之間有多少個完全平方數。 a = b = 0 代表結束。 範例輸入1 41 100 0 範例輸出23 想法先建一個陣列儲存該數是否為完全平方數，接著從 a 到 b 檢查陣列，計算共有幾個數符合條件。 程式碼 C++ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int a, b, c; bool squ[100001]; memset(squ, 0, sizeof(squ)); for(int i = 1; i &lt; 1000; ++i)&#123; if(i*i &lt; 100001)&#123; squ[i*i] = true; &#125; else break; &#125; while(cin &gt;&gt; a &gt;&gt; b)&#123; c = 0; if(a == 0 &amp;&amp; b == 0) break; for(int i = a; i &lt;= b; ++i)&#123; if(squ[i]) ++c; &#125; cout &lt;&lt; c &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"d255: 11417 - GCD","path":"2022/02/05/d255-11417/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d255 內容G=0; for(i=1;i &lt; N;i++) for(j=i+1;j&lt;=N;j++) { G+=GCD(i,j); } /* GCD()為一個求兩個輸入數字的最大公因數的函數*/ 給定 N(1 &lt; N &lt; 501)，輸出 G。N = 0 代表結束。 範例輸入101005000 範例輸出6713015442011 想法跟著題目走。 可用內建函式 __gcd(i, j)。 程式碼 C++ 123456789101112131415161718#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, G; while(cin &gt;&gt; N &amp;&amp; N)&#123; G = 0; for(int i = 1; i &lt; N; ++i)&#123; for(int j = i+1; j &lt;= N; ++j)&#123; G += __gcd(i, j); &#125; &#125; cout &lt;&lt; G &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"e513: 11349 - Symmetric Matrix","path":"2022/02/05/e513-11349/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e513 內容給定一個正方形矩陣，判斷是否對稱。 定義:對稱矩陣所有元素都是非負的並且相對於該矩陣的中心對稱。任何其他矩陣都被認為是非對稱的。 輸入第一列整數 T (T &lt;= 300)代表測資數，第二列為矩陣邊長 n (0 &lt; n &lt;= 100)，接著為矩陣(元素範圍為-2^32 &lt;= Mij &lt;= 2^32)。 範例輸入2N = 35 1 32 0 23 1 5N = 35 1 32 0 20 1 5 範例輸出Test #1: Symmetric.Test #2: Non-symmetric. 想法將矩陣以一維陣列方式儲存，長度為 n*n，依序判斷陣列內第一個與最後一個、第二個與倒數第二個…是否相等，直到到達矩陣中央，過程中可順便查看是否有負數。 程式碼 C++ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; long long T, n, mp[10001], L, R; char temp; bool suc; cin &gt;&gt; T; for(int c = 1; c &lt;= T; ++c)&#123; cin &gt;&gt; temp &gt;&gt; temp &gt;&gt; n; for(int i = 0; i &lt; n*n; ++i) cin &gt;&gt; mp[i]; L = 0, R = n*n - 1, suc = true; while(L &lt;= R)&#123; if(mp[L] != mp[R])&#123; suc = false; break; &#125; else if(mp[L] &lt; 0 || mp[R] &lt; 0)&#123; suc = false; break; &#125; ++L, --R; &#125; cout &lt;&lt; &quot;Test #&quot; &lt;&lt; c &lt;&lt; &quot;: &quot;; if(suc) cout &lt;&lt; &quot;Symmetric.\\n&quot;; else cout &lt;&lt; &quot;Non-symmetric.\\n&quot;; &#125; return 0;&#125;"},{"title":"c813: 11332 - Summing Digits","path":"2022/02/05/c813-11332/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c813 內容對於所有正整數 n ，我們定義一函數 f(n) 為 n 的每一個十進位數字的總和，若再把 f(n) 代入函數中可得最到 n,f(n),f(f(n)),f(f(f(n)))… 最後得到僅有一位數字的值，並定義該值為 g(n) 。 例如，當 n=1234567892 ，則： f(n)=1+2+3+4+5+6+7+8+9+2=47 f(f(n))=4+7=11 f(f(f(n)))=1+1=2 所以， g(1234567892)=2 。 給定一個整數 n (0 &lt; n &lt;= 2*10^9)，輸出 g(n)。 n = 0 代表結束。 範例輸入2114712345678920 範例輸出2222 想法跟找 n 除以 9 的餘數差不多，差別只在於若整除則輸出 9 。 程式碼 C++ 12345678910111213#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n; while(cin &gt;&gt; n &amp;&amp; n)&#123; if(n % 9 == 0) cout &lt;&lt; 9 &lt;&lt; &quot;\\n&quot;; else cout &lt;&lt; n%9 &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"d750: 11321 - Sort! Sort!! and Sort!!!","path":"2022/02/05/d750-11321/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d750 內容給你兩個整數 N (0 &lt; N &lt;= 10000), M (0 &lt; M &lt;= 10000)，你要依照某些規則排序N個整數。先利用每個數字除以M的餘數由小到大排，若排序中比較的兩數為一奇一偶且兩數除以M 的餘數相等，則奇數要排在偶數前面。若兩奇數除以M餘數大小相等，則原本數值較大的奇數排在前面。同樣的，若兩偶數除以M餘數大小相等，則較小的偶數排在前面。 輸入第一行有兩個整數 N, M ，接著有 N 個需排列的數。 範例輸入15 31234567891011121314150 0 範例輸出15 31593612137141011528140 0 想法建一個 struct 分別儲存每個數的值、是否為奇數、除以 M 之餘數，接著按照題目要求排列。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;struct Node&#123; int num; bool odd; int mod;&#125;;bool cmp(Node a, Node b)&#123; if(a.mod == b.mod)&#123; if(a.odd != b.odd) return a.odd; else if(a.odd) return a.num &gt; b.num; else return a.num &lt; b.num; &#125; return a.mod &lt; b.mod;&#125;int main()&#123; fastio; int N, M; Node node[10001]; while(cin &gt;&gt; N &gt;&gt; M)&#123; cout &lt;&lt; N &lt;&lt; &quot; &quot; &lt;&lt; M &lt;&lt; &quot;\\n&quot;; if(N == 0 &amp;&amp; M == 0) break; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; node[i].num; node[i].odd = (node[i].num &amp; 1) ? true : false; node[i].mod = node[i].num % M; &#125; sort(node, node+N, cmp); for(int i = 0; i &lt; N; ++i) cout &lt;&lt; node[i].num &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"d189: 11150 - Cola","path":"2022/02/05/d189-11150/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d189 內容3瓶空可樂罐換一瓶可樂。給定開局可樂數 N (1 &lt;= N &lt;= 200)，求最多可喝到幾瓶可樂。 空瓶可和朋友借，但最後要還。 範例輸入89 範例輸出1213 想法公式解，所求為 N*3/2。 參考資料:经典数学问题“空瓶换酒”求解 程式碼 C++ 123456789101112#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N; while(cin &gt;&gt; N)&#123; cout &lt;&lt; N*3/2 &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"f444: 10268 - 498-bis","path":"2022/02/04/f444-10268/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=f444 內容給定 X 與方程式，求微分後的值。 輸入164 8 7 6 3代表X = 164X^4 + 8X^3 + 7X^2 + 6X^1 + 3 範例輸入71 -121 1 1 範例輸出15 想法使用 getline 讀取方程式，接著利用 stringstream 將數字分別取出存入陣列。 遍歷一次陣列，運用微分公式 f′(x) = n*x^(n-1)，即可求解。 程式碼 C++ 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int x ,mp[1000], c, sum, num; string s; stringstream ss; while(cin &gt;&gt; x &gt;&gt; ws)&#123; c = 0, sum = 0; getline(cin, s); ss &lt;&lt; s; while(ss &gt;&gt; mp[c++]); --c; ss.str(&quot;&quot;), ss.clear(); for(int i = 0; i &lt; c-1; ++i)&#123; num = c-i-1; sum += mp[i]*num*pow(x, num-1); &#125; cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e606: 10057 - A mid-summer nights dream","path":"2022/02/04/e606-10057/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e606 內容給定一個數列，找出一個整數 A 使得到數列上每個點的距離和為最小。 每組測資第一列為數列長度 n (0 &lt; n &lt;= 1000000)，接著為數列。 依序輸出1. 最小的 A。2. 輸入中有多少個數與 A 有相同性質。3. 有幾種可能的 A。 範例輸入2101041224 範例輸出10 2 12 2 1 想法排序後，若此數列長度為奇數，令 L = R = 中位數，若為偶數，令 L 跟 R 分別為中間兩點。 此時 L 為最小的 A ， R - L + 1 為 A 的數量。 接著遍歷一次數列即可知道輸入中有多少個數與 A 有相同性質(找數列中介於 L 與 R 之間的數)。 程式碼 C++ 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int mp[1000001];int main()&#123; fastio; int n, L, R, A, num; while(cin &gt;&gt; n)&#123; A = 0; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; mp[i]; sort(mp, mp + n); if(n &amp; 1)&#123; L = mp[n &gt;&gt; 1]; R = L; &#125; else &#123; L = mp[(n &gt;&gt; 1) - 1]; R = mp[n &gt;&gt; 1]; &#125; num = R - L + 1; for(int i = 0; i &lt; n; ++i)&#123; if(mp[i] &gt; R) break; if(mp[i] &gt;= L &amp;&amp; mp[i] &lt;= R) ++A; &#125; cout &lt;&lt; L &lt;&lt; &quot; &quot; &lt;&lt; A &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e605: 10189 - Minesweeper","path":"2022/02/04/e605-10189/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e605 內容踩地雷。 輸入第一列 n, m(0 &lt; n, m &lt;= 100)代表地圖大小。n = m = 0 代表結束。 範例輸入4 4*……..*..….3 5**……...*…0 0 範例輸出Field #1:*10022101*101110 Field #2:**100332001*100 想法另開一個陣列紀錄附近地雷數，先找出所有地雷所在位置標記到另一陣列中，接著依序查找地圖中每個點，若此處為地雷，以另一個陣列更新附近 8 個點之數值(若為地雷則跳過)。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int b4i[] = &#123;0, 1, 0, -1, -1, -1, 1, 1&#125;, b4j[] = &#123;1, 0, -1, 0, -1, 1, -1, 1&#125;;int main()&#123; fastio; int n, m, mines[101][101], c = 0; char mp[101][101]; while(cin &gt;&gt; n)&#123; cin &gt;&gt; m; if(n == 0 &amp;&amp; m == 0) break; memset(mines, 0, sizeof(mines)); for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; cin &gt;&gt; mp[i][j]; if(mp[i][j] == &#x27;*&#x27;) mines[i][j] = 9; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; if(mp[i][j] == &#x27;*&#x27;)&#123; for(int dir = 0; dir &lt; 8; ++dir)&#123; int di = i + b4i[dir], dj = j + b4j[dir]; if(di &gt;= 0 &amp;&amp; di &lt; n &amp;&amp; dj &gt;= 0 &amp;&amp; dj &lt; m)&#123; if(mines[di][dj] != 9)&#123; ++mines[di][dj]; &#125; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; &quot;Field #&quot; &lt;&lt; ++c &lt;&lt; &quot;:\\n&quot;; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; m; ++j)&#123; if(mines[i][j] == 9) cout &lt;&lt; &quot;*&quot;; else cout &lt;&lt; mines[i][j]; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e579: 10050 - Hartals","path":"2022/02/04/e579-10050/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e579 內容一個社會研究組織採用了一組簡單的參數來模擬我們國家政黨運作的行為。參數之一是一個正整數h，h稱為罷會(hartal)參數，它表示同一個政黨連續兩次連續罷會的間隔天數。儘管該參數有點過於簡單，但還是能用於預測政黨罷會造成的影響。 以下範例為您說明：考慮現在有三個政黨。假設h1 = 3，h2 = 4，h3 = 8，其中hi是第i方的罷會參數。現在，我們將模擬這三個方在N = 14天的罷會行為。模擬的起始天一定是星期天，並假設在每週的假日(星期五和星期六)不會有任何罷會情形。 Days 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr SaParty 1 x x x xParty 2 x x xParty 3 xHartals 1 2 3 4 5 上面的模擬顯示，在14天內將會罷會5天(分別在第3、4、8、9和12天)。第6天沒有罷會，因為它屬於假日(星期五)。由此可知我們在2週內損失了5個工作天。 在這個問題中，考慮到多個政黨的罷會參數和天數N，您的工作是計算出這N天內我們因為罷會損失多少工作天。 輸入第一列 T 代表測資數，每組測資第一列包含一個整數 N (7 &lt;= N &lt;= 3650)代表模擬天數，下一列包含一個整數P (1 ≤ P ≤ 100)表示政黨數，接下來的P行，第i行包含一個正整數hi(永遠不會是7的倍數)，代表第i個政黨的罷會參數。 範例輸入2143348100412152540 範例輸出515 想法一天一天的模擬，若該天為假日( i+1 或 i 整除 6)則跳過，若否，則判斷是否有參數可使其整除。 程式碼 C++ 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int T, N, P, mp[101], lose; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; N &gt;&gt; P; lose = 0; for(int i = 0; i &lt; P; ++i) cin &gt;&gt; mp[i]; for(int i = 1; i &lt;= N; ++i)&#123; if((i + 1) % 7 == 0 || i % 7 == 0) continue; for(int j = 0; j &lt; P; ++j)&#123; if(i &gt;= mp[j] &amp;&amp; i % mp[j] == 0)&#123; ++lose; break; &#125; &#125; &#125; cout &lt;&lt; lose &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e578: 10222 - Decode the Mad man","path":"2022/02/04/e578-10222/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e578 內容給定多個字元，輸出其在鍵盤上左邊第二個鍵(空白或換行直接輸出)。 範例輸入k[r dyt i[op ‘[nt ]y[jyd. 範例輸出how are youi love program 想法先用 map 建立好字元與其對應的字元，例如 mp[‘e’] = ‘q’ 代表 ‘e’ 的左邊第二鍵為 ‘q’。 使用 getline 一次讀取一列，依序查詢其所對應的字元，並且輸出。 程式碼 C++ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;map&lt;char, char&gt; mp;int main()&#123; fastio; string s; mp[&#x27;2&#x27;] = &#x27;`&#x27;, mp[&#x27;3&#x27;] = &#x27;1&#x27;, mp[&#x27;4&#x27;] = &#x27;2&#x27;, mp[&#x27;5&#x27;] = &#x27;3&#x27;, mp[&#x27;6&#x27;] = &#x27;4&#x27;, mp[&#x27;7&#x27;] = &#x27;5&#x27;, mp[&#x27;8&#x27;] = &#x27;6&#x27;, mp[&#x27;9&#x27;] = &#x27;7&#x27;, mp[&#x27;0&#x27;] = &#x27;8&#x27;, mp[&#x27;-&#x27;] = &#x27;9&#x27;, mp[&#x27;=&#x27;] = &#x27;0&#x27;; mp[&#x27;e&#x27;] = &#x27;q&#x27;, mp[&#x27;r&#x27;] = &#x27;w&#x27;, mp[&#x27;t&#x27;] = &#x27;e&#x27;, mp[&#x27;y&#x27;] = &#x27;r&#x27;, mp[&#x27;u&#x27;] = &#x27;t&#x27;, mp[&#x27;i&#x27;] = &#x27;y&#x27;, mp[&#x27;o&#x27;] = &#x27;u&#x27;, mp[&#x27;p&#x27;] = &#x27;i&#x27;, mp[&#x27;[&#x27;] = &#x27;o&#x27;, mp[&#x27;]&#x27;] = &#x27;p&#x27;, mp[&#x27;\\\\&#x27;] = &#x27;[&#x27;; mp[&#x27;d&#x27;] = &#x27;a&#x27;, mp[&#x27;f&#x27;] = &#x27;s&#x27;, mp[&#x27;g&#x27;] = &#x27;d&#x27;, mp[&#x27;h&#x27;] = &#x27;f&#x27;, mp[&#x27;j&#x27;] = &#x27;g&#x27;, mp[&#x27;k&#x27;] = &#x27;h&#x27;, mp[&#x27;l&#x27;] = &#x27;j&#x27;, mp[&#x27;;&#x27;] = &#x27;k&#x27;, mp[&#x27;\\&#x27;&#x27;] = &#x27;l&#x27;; mp[&#x27;c&#x27;] = &#x27;z&#x27;, mp[&#x27;v&#x27;] = &#x27;x&#x27;, mp[&#x27;b&#x27;] = &#x27;c&#x27;, mp[&#x27;n&#x27;] = &#x27;v&#x27;, mp[&#x27;m&#x27;] = &#x27;b&#x27;, mp[&#x27;,&#x27;] = &#x27;n&#x27;, mp[&#x27;.&#x27;] = &#x27;m&#x27;, mp[&#x27;/&#x27;] = &#x27;,&#x27;; while(getline(cin, s))&#123; for(int i = 0; i &lt; s.length(); ++i)&#123; if(s[i] == &#x27; &#x27;) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; mp[s[i]]; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e575: 10908 - Largest Squares","path":"2022/02/04/e575-10908/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e575 內容給定一個字元矩形及中心點座標，找出以此座標當中心所對應的最大正方形邊長。 輸入第一列 T (T &lt; 21)代表測資數，每組測資第一列包含矩形高度 M，寬度 N(1 &lt;= M, N &lt;= 100)，詢問數量 Q (Q &lt; 21)，接著有 Q 列中心點座標。 範例輸入17 10 4abbbaaaaaaabbbaaaaaaabbbaaaaaaaaaaaaaaaaaaaaaaaaaaaaccaaaaaaaaccaaaaaa1 22 44 65 2 範例輸出7 10 43151 想法將矩形內每一點都視為正方形的右下角座標，發現以該點為右下角座標所構成的最大正方形邊長，取決於其左、上、左上這三點構成之正方形最大邊長的最小值 + 1，即可建一個陣列儲存。 因輸入為中心點座標，而陣列儲存數值為右下角，因此需不斷向陣列右下角查詢，直到其值無法再更大。 參考資料:YUI HUANG 演算法學習筆記 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int T, m, n, q, dp[101][101]; char mp[101][101]; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; q; for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; cin &gt;&gt; mp[i][j]; &#125; &#125; for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == 0 || j == 0) dp[i][j] = 1; else if(mp[i][j] == mp[i-1][j-1] &amp;&amp; mp[i][j] == mp[i-1][j] &amp;&amp; mp[i][j] == mp[i][j-1])&#123; dp[i][j] = min(&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125;) + 1; &#125; else dp[i][j] = 1; &#125; &#125; int y, x, ans; cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; &quot;\\n&quot;; while(q--)&#123; cin &gt;&gt; y &gt;&gt; x; ans = 1; ++y, ++x; while(y &lt; m &amp;&amp; x &lt; n)&#123; if(dp[y][x] &gt;= ans+2)&#123; ans += 2; ++y, ++x; &#125; else break; &#125; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125; &#125; return 0;&#125;"},{"title":"e566: 10190 - Divide, But Not Quite Conquer!","path":"2022/02/03/e566-10190/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e566 內容給定兩非負整數 n, m (n, m &lt; 2000000000)，不斷拿 n 除以 m ，並更新 n = n / m，若直到 n = 1 的過程中皆可整除，依序輸出每個 n ，若否，輸出 ‘Boring!’。 範例輸入125 530 380 281 3 範例輸出125 25 5 1Boring!Boring!81 27 9 3 1 想法不斷將 n 除以 m 並更新 n ，使用 queue 紀錄每個 n ，若皆可整除，則運用 queue 特性(先進先出)印出，若否，則輸出’Boring!’，每完成一筆測資後，需將 queue 清空(將裡面元素不斷 pop 出來，直到 empty)。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, m, temp; queue&lt;int&gt; q; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(m == 0)&#123; cout &lt;&lt; &quot;Boring!\\n&quot;; continue; &#125; q.push(n); while(n != 1)&#123; if(n % m == 0)&#123; n /= m; q.push(n); &#125; else&#123; cout &lt;&lt; &quot;Boring!&quot;; while(!q.empty()) q.pop(); break; &#125; &#125; while(!q.empty())&#123; temp = q.front(); q.pop(); cout &lt;&lt; temp &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e561: 00299 - Train Swapping","path":"2022/02/03/e561-00299/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e561 內容給定一數列，一次只能交換相鄰兩數，問最少需交換幾次才能完成排序(由小到大)。 輸入第一列 N 代表測資數，每組測資第一列有一整數 L (0 &lt;= L &lt;= 50) 代表數列長度，接著為數列。 範例輸入331 3 244 3 2 122 1 範例輸出Optimal train swapping takes 1 swaps.Optimal train swapping takes 6 swaps.Optimal train swapping takes 1 swaps. 想法分別計算每個數的後面有多少個數比它小，最後加總起來即為所求。 程式碼 C++ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, L, mp[51], change; cin &gt;&gt; N; while(N--)&#123; cin &gt;&gt; L; change = 0; for(int i = 0; i &lt; L; ++i) cin &gt;&gt; mp[i]; for(int i = 0; i &lt; L - 1; ++i)&#123; for(int j = i + 1; j &lt; L; ++j)&#123; if(mp[i] &gt; mp[j]) ++change; &#125; &#125; cout &lt;&lt; &quot;Optimal train swapping takes &quot; &lt;&lt; change &lt;&lt; &quot; swaps.\\n&quot;; &#125;&#125;"},{"title":"e555: 10170 - The Hotel with Infinite Rooms","path":"2022/02/03/e555-10170/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e555 內容有一家奇怪的酒店，房間無限。來這家酒店的團體，請遵循以下規則：a）同時，只有能有一個旅行團可以租用酒店。b）每個旅行團在入住日的早晨到達，並在退房日的晚上離開酒店。c）後入住的旅行團需要在前一團退房後的隔天早晨，才能入住d）除了第一團，其他旅行團人數都比前一團多一人e）有n名成員的旅行團則會在酒店停留n天。 輸入每一列包含第一組旅行團人數 S (1 &lt;= S &lt;= 10000)、第幾天查找 D (1 &lt;= D &lt; 10^15)。輸出第 D 天入住旅行團人數。 範例輸入1 63 103 14 範例輸出356 想法假設 X = 第 D 天入住旅行團人數。 使用等差數列公式得到 (S+X)(X-S+1) / 2 &gt;= D。化簡為 X^2 + X - S^2 + S - 2D &gt;= 0。解一元二次方程式，對 X 向上取整即為所求。 程式碼 C++ 123456789101112131415#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int S; long long D, C; long long ans; while(cin &gt;&gt; S &gt;&gt; D)&#123; C = -S*S+S-2*D; ans = ceil((-1.0 + sqrt(1-4*C)) / 2.0); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e545: 10019 - Funny Encryption Method","path":"2022/02/03/e545-10019/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e545 內容給定一個十進制整數 N (0 &lt; N &lt;= 9999)，分別計算將 N 當作十進位數值以及十六進位數值，轉換成二進位共有幾個 1 。 輸入第一列 T (0 &lt; T &lt;= 1000)代表測資數。 範例輸入32651111234 範例輸出3 56 35 5 想法若是將 N 當成十進位看，直接轉二進位計算。若是當十六進位看，先將其轉為十進位，再轉二進位。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;void dec(int);void hex(int);int main()&#123; fastio; int T, N; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; N; dec(N); hex(N); &#125;&#125;void dec(int n)&#123; int c = 0; while(n &gt; 0)&#123; if(n &amp; 1) ++c; n &gt;&gt;= 1; &#125; cout &lt;&lt; c &lt;&lt; &quot; &quot;;&#125;void hex(int n)&#123; int c = 0, dig = 0, num = 0, temp; while(n &gt; 0)&#123; num += (n % 10) * pow(16, dig); n /= 10; ++dig; &#125; while(num &gt; 0)&#123; if(num &amp; 1) ++c; num &gt;&gt;= 1; &#125; cout &lt;&lt; c &lt;&lt; &quot;\\n&quot;;&#125;"},{"title":"e531: 10415 - Eb Alto Saxophone Player","path":"2022/02/02/e531-10415/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e531 內容給定一歌曲，求出用薩克斯風演奏時各個手指按壓次數(下一音符用不到則放開)。 每個音調的指法如下：c: finger 2~4, 7~10d: finger 2~4, 7~9e: finger 2~4, 7, 8f: finger 2~4, 7g: finger 2~4a: finger 2, 3b: finger 2C: finger 3D: finger 1~4, 7~9E: finger 1~4, 7, 8F: finger 1~4, 7G: finger 1~4A: finger 1~3B: finger 1~2 輸入第一列有一整數 t (1 &lt;= t &lt;= 1000)代表測資數。 範例輸入3cdefgabBAGFEDCCbCaDCbCbCCbCbabCCbCbabae 範例輸出0 1 1 1 0 0 1 1 1 11 1 1 1 0 0 1 1 1 01 8 10 2 0 0 2 2 1 0 想法先用 map 紀錄各音符指法，接著模擬演奏狀況，使用一陣列紀錄手指目前是否按壓，一陣列紀錄按壓次數。 歌曲可能是空的，因此使用 getline 讀取(string 不會讀取空格)。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; map &lt;char, vector&lt;int&gt;&gt; mp; mp[&#x27;c&#x27;] = &#123;0, 1, 1, 1, 0, 0, 1, 1, 1, 1&#125;; mp[&#x27;d&#x27;] = &#123;0, 1, 1, 1, 0, 0, 1, 1, 1, 0&#125;; mp[&#x27;e&#x27;] = &#123;0, 1, 1, 1, 0, 0, 1, 1, 0, 0&#125;; mp[&#x27;f&#x27;] = &#123;0, 1, 1, 1, 0, 0, 1, 0, 0, 0&#125;; mp[&#x27;g&#x27;] = &#123;0, 1, 1, 1, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;a&#x27;] = &#123;0, 1, 1, 0, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;b&#x27;] = &#123;0, 1, 0, 0, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;C&#x27;] = &#123;0, 0, 1, 0, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;D&#x27;] = &#123;1, 1, 1, 1, 0, 0, 1, 1, 1, 0&#125;; mp[&#x27;E&#x27;] = &#123;1, 1, 1, 1, 0, 0, 1, 1, 0, 0&#125;; mp[&#x27;F&#x27;] = &#123;1, 1, 1, 1, 0, 0, 1, 0, 0, 0&#125;; mp[&#x27;G&#x27;] = &#123;1, 1, 1, 1, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;A&#x27;] = &#123;1, 1, 1, 0, 0, 0, 0, 0, 0, 0&#125;; mp[&#x27;B&#x27;] = &#123;1, 1, 0, 0, 0, 0, 0, 0, 0, 0&#125;; int t; string s; bool vis[11]; int cnt[11]; cin &gt;&gt; t; cin.ignore(); while(t--)&#123; getline(cin, s); memset(vis, 0, sizeof(vis)); memset(cnt, 0, sizeof(cnt)); for(int i = 0; i &lt; s.length(); ++i)&#123; for(int j = 0; j &lt; 10; ++j)&#123; if(mp[s[i]][j])&#123; if(vis[j]) continue; else &#123; ++cnt[j]; vis[j] = true; &#125; &#125; else vis[j] = false; &#125; &#125; for(int i = 0; i &lt; 10; ++i)&#123; cout &lt;&lt; cnt[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"e516: 10409 - Die Game","path":"2022/02/02/e516-10409/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e516 內容有一骰子在四個方向上滾動(東，南，西，北)，給定一串指令，求出骰子最終頂部的數字。 開局方向對應數字分別為頂面(1)、北面(2)、西面(3)。 指令 ‘north’ 代表北面變為新的底，頂面變為新的北，依此類推。 輸入第一列 n (n &lt;= 1024)代表測資數，等於0時結束。 範例輸入1north3northeastsouth0 範例輸出51 想法先用 map 將方向與數字配對，接著模擬骰子滾動，一次判斷一個指令，依照指令動作，更新各個面之相對應數字，最後的頂面對應數字即為所求。 參考資料:YUI HUANG 演算法學習筆記 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, temp; string s; while(cin &gt;&gt; n &amp;&amp; n)&#123; map &lt;string, int&gt; mp; mp[&quot;top&quot;] = 1, mp[&quot;north&quot;] = 2, mp[&quot;west&quot;] = 3; mp[&quot;bottom&quot;] = 6, mp[&quot;south&quot;] = 5, mp[&quot;east&quot;] = 4; while(n--)&#123; cin &gt;&gt; s; if(s == &quot;north&quot;)&#123; temp = mp[&quot;top&quot;]; mp[&quot;top&quot;] = mp[&quot;south&quot;]; mp[&quot;south&quot;] = mp[&quot;bottom&quot;]; mp[&quot;bottom&quot;] = mp[&quot;north&quot;]; mp[&quot;north&quot;] = temp; &#125; else if(s == &quot;east&quot;)&#123; temp = mp[&quot;top&quot;]; mp[&quot;top&quot;] = mp[&quot;west&quot;]; mp[&quot;west&quot;] = mp[&quot;bottom&quot;]; mp[&quot;bottom&quot;] = mp[&quot;east&quot;]; mp[&quot;east&quot;] = temp; &#125; else if(s == &quot;west&quot;)&#123; temp = mp[&quot;top&quot;]; mp[&quot;top&quot;] = mp[&quot;east&quot;]; mp[&quot;east&quot;] = mp[&quot;bottom&quot;]; mp[&quot;bottom&quot;] = mp[&quot;west&quot;]; mp[&quot;west&quot;] = temp; &#125; else &#123; temp = mp[&quot;top&quot;]; mp[&quot;top&quot;] = mp[&quot;north&quot;]; mp[&quot;north&quot;] = mp[&quot;bottom&quot;]; mp[&quot;bottom&quot;] = mp[&quot;south&quot;]; mp[&quot;south&quot;] = temp; &#125; &#125; cout &lt;&lt; mp[&quot;top&quot;] &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"e512: 10242 - Fourth Point!!","path":"2022/02/02/e512-10242/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e512 內容給定平行四邊形的兩個相鄰邊端點座標(x, y)，求出第四個點座標(x, y)。 輸出取到小數點後三位。 範例輸入0.000 0.000 0.000 1.000 0.000 1.000 1.000 1.0001.000 0.000 3.500 3.500 3.500 3.500 0.000 1.0001.866 0.000 3.127 3.543 3.127 3.543 1.412 3.145 範例輸出1.000 0.000-2.500 -2.5000.151 -0.398 想法找出兩相鄰邊之交點，求出交點與另外兩點其中一點的 x, y 變化量，對另一點做運算，即可得到第四點。 程式碼 C++ 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; double x[4], y[4], xx, yy; double dx, dy; while(cin &gt;&gt; x[0] &gt;&gt; y[0])&#123; for(int i = 1; i &lt; 4; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i]; if(x[0] == x[2] &amp;&amp; y[0] == y[2])&#123; dx = x[1] - x[0], dy = y[1] - y[0]; xx = x[3] + dx, yy = y[3] + dy; &#125; else if(x[1] == x[2] &amp;&amp; y[1] == y[2])&#123; dx = x[3] - x[2], dy = y[3] - y[2]; xx = x[0] + dx, yy = y[0] + dy; &#125; else if(x[1] == x[3] &amp;&amp; y[1] == y[3])&#123; dx = x[2] - x[1], dy = y[2] - y[1]; xx = x[0] + dx, yy = y[0] + dy; &#125; else &#123; dx = x[2] - x[0], dy = y[2] - y[0]; xx = x[1] + dx, yy = y[1] + dy; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; xx &lt;&lt; &quot; &quot; &lt;&lt; yy &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e510: 10056 - What is the Probability?","path":"2022/02/02/e510-10056/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e510 內容給定玩家數 N ，一個成功事件發生機率 p，玩家依序行動(不只一輪)，求第 i 個玩家成功的機率(有人成功即遊戲結束)。 第一列有一整數 S (S &lt;= 1000)表示測資數，接著有三數分別為 N, p, i。 範例輸入22 0.166666 12 0.166666 2 範例輸出0.54550.4545 想法完全沒有想法，於是跑去看大神教學。 看完之後，得到一個表格。 玩家 第一輪 第二輪 … 第R輪 1 (1-p) (1-p)^N * (1-p) (1-p)^N(R-1) * (1-p) 2 (1-p)^2 (1-p)^N * (1-p)^2 (1-p)^N(R-1) * (1-p)^2 … … … … i (1-p)^(i-1) * p (1-p)^N * (1-p)^(i-1) * p (1-p)^N(R-1) * (1-p)^(i-1) * p … N 若要輪到第 i 個玩家，則前面必須都為失敗。可以發現第 i 個玩家的成功機率為 p(i在第一輪成功) + p(i在第二輪成功) + … + p(i在第R輪成功)，是一個無窮等比級數，找出首項為 (1-p)^(i-1) * p，公比為 (1-p)^N。 即可利用公式 首項/(1-公比) 求解。 參考資料:YUI HUANG 演算法學習筆記 程式碼 C++ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int S, N, i; double p; cin &gt;&gt; S; while(S--)&#123; cin &gt;&gt; N &gt;&gt; p &gt;&gt; i; if(p == 0) &#123; cout &lt;&lt; &quot;0.0000\\n&quot;; continue; &#125; double first = pow(1.0 - p, i - 1) * p; double r = pow(1.0 - p, N); cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; first / (1.0 - r) &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"e507: 10252 - Common Permutation","path":"2022/02/02/e507-10252/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=e507 內容給定兩個由小寫字母組成的字串，印出兩字串共同擁有的字母(可重複)，按照字母順序排列。 範例輸入prettywomenwalkingdownthestreet 範例輸出enwet 想法使用兩個陣列分別計算兩字串字母出現次數，使 a 對應到 0 、 b 對應到 1 … z 對應到 25，設 wa 陣列表示 a 字串字母出現次數，則 wa[2] = 5 代表 c 在此字串中出現 5 次。 最後由 0 (a) 掃到 25 (z)，檢查此字母是否同時在兩字串中出現，若是，則更新兩陣列數值，並且輸出此字母，直到其中一方為 0 ，接著檢查下一個字母，到 z 為止。 程式碼 C++ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string a, b; int wa[26], wb[26]; while(cin &gt;&gt; a &gt;&gt; b)&#123; memset(wa, 0, sizeof(wa)); memset(wb, 0, sizeof(wb)); for(int i = 0; i &lt; a.length(); ++i) ++wa[a[i]-&#x27;a&#x27;]; for(int i = 0; i &lt; b.length(); ++i) ++wb[b[i]-&#x27;a&#x27;]; for(int i = 0; i &lt; 26; ++i)&#123; while(wa[i] != 0 &amp;&amp; wb[i] != 0)&#123; cout &lt;&lt; char(i+&#x27;a&#x27;); --wa[i], --wb[i]; &#125; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"d672: 10922 - 2 the 9s","path":"2022/02/02/d672-10922/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d672 內容使用遞迴方法判斷一數 N (可能很大)是否為 9 的倍數，並且求出此遞迴的深度。 遞迴方法(假設 N = 837):8 + 3 + 7 -&gt; 18 深度:11 + 8 -&gt; 9 深度:2(結束)。 當 N = 0 代表輸入結束。 範例輸入999999999999999999999999999999999999999999999999999988370 範例輸出999999999999999999999 is a multiple of 9 and has 9-degree 3.9 is a multiple of 9 and has 9-degree 1.9999999999999999999999999999998 is not a multiple of 9.837 is a multiple of 9 and has 9-degree 2. 想法使用 string 讀取輸入，先進行第一次的運算，得到的數值一定為 int 範圍，之後每次得到新數值都將其轉為 string 型態方便操作(利用 stringstream 進行轉換)，直到數值等於 9 。 像是 999999999999999999999 (string 型態) 即可用字元方式分別取出，得到新數值 189 (int 型態)，此為一個深度。接者將其轉為 string 型態，189 (string 型態)，用字元方式分別取出，得到新數值 18 (int 型態)。此為第二個深度。18 (int 型態) -&gt; 18 (string 型態)，得到 9 (int 型態)，此為第三個深度。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int degree(string);int main()&#123; fastio; string s; int ans; while(cin &gt;&gt; s)&#123; if(s == &quot;0&quot;) break; ans = degree(s); cout &lt;&lt; s &lt;&lt; &quot; is &quot;; if(ans &gt; 0) cout &lt;&lt; &quot;a multiple of 9 and has 9-degree &quot; &lt;&lt; ans &lt;&lt; &quot;.\\n&quot;; else cout &lt;&lt; &quot;not a multiple of 9.\\n&quot;; &#125; return 0;&#125;int degree(string s1)&#123; int c = 1, sum = 0; stringstream ss; string temp; for(int i = 0; i &lt; s1.length(); ++i)&#123; sum += s1[i]-&#x27;0&#x27;; &#125; while(sum &gt; 10)&#123; ss &lt;&lt; sum, ss &gt;&gt; temp; sum = 0; for(int i = 0; i &lt; temp.length(); ++i)&#123; sum += temp[i]-&#x27;0&#x27;; &#125; ++c; ss.str(&quot;&quot;), ss.clear(); &#125; if(sum == 9) return c; else return 0;&#125;"},{"title":"d492: 10226 - Hardwood species","path":"2022/02/02/d492-10226/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d492 內容給定若干列字串，計算各字串所占的百分比(取到小數點第四位)，並按照字典序排列。 第一列有一個正整數 n 代表測資數。 範例輸入2 Red AlderAshAspenBasswoodAshBeechYellow BirchAshCherryCottonwoodAshCypressRed ElmGumHackberryWhite OakHickoryPecanHard MapleWhite OakSoft MapleRed OakRed OakWhite OakPoplanSassafrasSycamoreBlack WalnutWillow Red AlderAshAshAspen 範例輸出Ash 13.7931Aspen 3.4483Basswood 3.4483Beech 3.4483Black Walnut 3.4483Cherry 3.4483Cottonwood 3.4483Cypress 3.4483Gum 3.4483Hackberry 3.4483Hard Maple 3.4483Hickory 3.4483Pecan 3.4483Poplan 3.4483Red Alder 3.4483Red Elm 3.4483Red Oak 6.8966Sassafras 3.4483Soft Maple 3.4483Sycamore 3.4483White Oak 10.3448Willow 3.4483Yellow Birch 3.4483 Ash 50.0000Aspen 25.0000Red Alder 25.0000 想法使用 getline 一次讀取一列，存入 map 中計算出現次數，運用 map 特性(字串默認排序為字典序)，遍歷一次即可。 因輸入未給字串數量，需額外計算。 參考資料:inversion大神的小屋 程式碼 C++ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, counts; string s; map &lt;string, int&gt;::iterator iter; map &lt;string, int&gt; trees; cin &gt;&gt; n &gt;&gt; ws; for(int i = 0; i &lt; n; ++i)&#123; if(i) cout &lt;&lt; &quot;\\n&quot;; trees.clear(), counts = 0; while(getline(cin, s) &amp;&amp; s.size())&#123; ++trees[s], ++counts; &#125; for(iter = trees.begin(); iter != trees.end(); ++iter)&#123; cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; iter -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; iter -&gt; second * 100.0 / counts &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125;"},{"title":"d387: 10235 - Simply Emirp","path":"2022/02/01/d387-10235/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d387 內容定義 ‘emirp’ 為｢本身是和反過來都是質數的數。 給定一個整數 N (1 &lt; N &lt; 1000000)，判斷此數，是否為質數、是否為 ‘emirp’。 範例輸入171819179199131 範例輸出17 is emirp.18 is not prime.19 is prime.179 is emirp.199 is emirp.131 is prime. 想法先把1000000內是否為質數的結果存入陣列(建質數表)。 若 N 為質數，判斷是否為 ‘emirp’。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)#define mxn 1000000using namespace std;bool sieve[mxn];void prime_judge();int main()&#123; fastio; prime_judge(); int N, temp; string s; stringstream ss; while(cin &gt;&gt; N)&#123; if(sieve[N])&#123; cout &lt;&lt; N &lt;&lt; &quot; is not prime.\\n&quot;; continue; &#125; ss &lt;&lt; N; ss &gt;&gt; s; reverse(s.begin(), s.end()); ss.str(&quot;&quot;), ss.clear(); ss &lt;&lt; s; ss &gt;&gt; temp; ss.str(&quot;&quot;); ss.clear(); if(!sieve[temp] &amp;&amp; N != temp) cout &lt;&lt; N &lt;&lt; &quot; is emirp.\\n&quot;; else cout &lt;&lt; N &lt;&lt; &quot; is prime.\\n&quot;; &#125;&#125;void prime_judge()&#123; sieve[0] = sieve[1] = true; for(long long int i = 2; i &lt; mxn; ++i)&#123; if(!sieve[i])&#123; for(long long int j = i*i; j &lt; mxn; j += i)&#123; sieve[j] = true; &#125; &#125; &#125;&#125;"},{"title":"d306: 10193 - All You Need Is Love","path":"2022/02/01/d306-10193/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d306 內容給定兩個二進制正整數，任取一數減另一數，不斷重複，判斷最後兩數是否會相等。 第一列有一個整數 N (N &lt; 10000)，代表測資數，接著為兩數 a, b (1 &lt; a, b &lt;= 2^30)。 範例輸入51101111000110111100111111110010000000001101010100 範例輸出Pair #1: All you need is love!Pair #2: Love is not all you need!Pair #3: Love is not all you need!Pair #4: All you need is love!Pair #5: All you need is love! 想法先將兩數轉成十進制，再取最大公因數。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int to_dec(string);bool gcd(int, int);int main()&#123; fastio; int n, n1, n2; string s1, s2; bool suc; cin &gt;&gt; n; for(int c = 1; c &lt;= n; ++c)&#123; cin &gt;&gt; s1 &gt;&gt; s2; n1 = to_dec(s1); n2 = to_dec(s2); suc = gcd(n1, n2); cout &lt;&lt; &quot;Pair #&quot; &lt;&lt; c &lt;&lt; &quot;: &quot;; if(suc) cout &lt;&lt; &quot;All you need is love!\\n&quot;; else cout &lt;&lt; &quot;Love is not all you need!\\n&quot;; &#125;&#125;int to_dec(string s)&#123; int sum = 0; for(int i = 0; i &lt; s.length(); ++i)&#123; sum = sum * 2 + (s[i] - &#x27;0&#x27;); &#125; return sum;&#125;bool gcd(int a, int b)&#123; while(a != 0 &amp;&amp; b != 0)&#123; if(a &gt; b) a = a % b; else b = b % a; &#125; if(max(a, b) == 1) return false; return true;&#125;"},{"title":"留言板","path":"2022/02/01/留言板/","text":"…なん…だと…"},{"title":"d235: 10929 - You can say 11","path":"2022/02/01/d235-10929/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d235 內容給定一個正整數 N (可能很大)，判斷是否為11的倍數。 輸入 0 代表結束。 範例輸入11223330800293732345569350382971122340 範例輸出112233 is a multiple of 11.30800 is a multiple of 11.2937 is a multiple of 11.323455693 is a multiple of 11.5038297 is a multiple of 11.112234 is not a multiple of 11. 想法用 string 讀取，因為輸入可能超出 long long 範圍。 若奇數項和偶數項之差為11倍數，則此數為11的倍數。 程式碼 C++ 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string s; int odd, even; while(cin &gt;&gt; s)&#123; if(s == &quot;0&quot;) break; odd = even = 0; for(int i = 0; i &lt; s.length(); ++i)&#123; if(i &amp; 1) even += s[i]-&#x27;0&#x27;; else odd += s[i]-&#x27;0&#x27;; &#125; if(abs(odd-even) % 11 == 0) cout &lt;&lt; s &lt;&lt; &quot; is a multiple of 11.\\n&quot;; else cout &lt;&lt; s &lt;&lt; &quot; is not a multiple of 11.\\n&quot;; &#125; return 0;&#125;"},{"title":"d226: 10071 - Back to High School Physics","path":"2022/02/01/d226-10071/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d226 內容某一個粒子有一初速度和等加速度。假設在 t 秒後此粒子的速度為 v ，請問這個粒子在 2t 秒後所經過的位移是多少。 每組測資一列，分別代表 v (-100 &lt;= v &lt;= 100)、t (0 &lt;= t &lt;= 200)。 範例輸入0 05 12 範例輸出0120 想法 ## 程式碼 C++ 123456789101112#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int t, v; while(cin &gt;&gt; t)&#123; cin &gt;&gt; v; cout &lt;&lt; 2 * t * v &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"d123: 11063 - B2-Sequence","path":"2022/02/01/d123-11063/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d123 內容所謂「B2數列」係指一正整數數列 1&lt;= b1 &lt; b2 &lt; b3 …，其中所有的 bi + bj （i &lt;= j）皆不相等。 判斷某一數列是否為「B2數列」。 第一列 N (2 &lt;= N &lt;= 100)代表數列長度。 範例輸入41 2 4 843 7 10 14513 14 15 16 17 範例輸出Case #1: It is a B2-Sequence. Case #2: It is not a B2-Sequence. Case #3: It is not a B2-Sequence. 想法將 bi + bj 的值當陣列索引值判斷此數是否存在。 程式碼 C++ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, mp[101], temp, c = 0; bool vis[30000], suc; while(cin &gt;&gt; N)&#123; memset(vis, 0, sizeof(vis)); suc = true; for(int i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; mp[i]; &#125; for(int i = 0; i &lt; N; ++i)&#123; for(int j = i; j &lt; N; ++j)&#123; temp = mp[i]+mp[j]; if(vis[temp])&#123; suc = false; break; &#125; vis[temp] = true; &#125; if(!suc) break; &#125; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; ++c &lt;&lt; &quot;: &quot;; if(suc) cout &lt;&lt; &quot;It is a B2-Sequence.\\n\\n&quot;; else cout &lt;&lt; &quot;It is not a B2-Sequence.\\n\\n&quot;; &#125; return 0;&#125;"},{"title":"d097: 10038 - Jolly Jumpers","path":"2022/02/01/d097-10038/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=d097 內容給定一長度為 n (n &lt; 3000)之數列，若相鄰兩數之差的絕對值在 1 ~ n-1 皆有(不用照順序)，則輸出 Jolly，若否輸出 Not jolly。 第一個整數為 n ，接著為此數列。 範例輸入4 1 4 2 35 1 4 2 -1 6 範例輸出JollyNot jolly 想法將相鄰兩數之差當陣列索引值紀錄下來，接著從 1 開始遍歷此陣列。 程式碼 C++ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, mp[3000]; int temp; bool vis[3000], suc; while(cin &gt;&gt; n)&#123; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; mp[i]; for(int i = 1; i &lt; n; ++i)&#123; temp = abs(mp[i] - mp[i - 1]); vis[temp] = true; &#125; suc = true; for(int i = 1; i &lt; n; ++i)&#123; if(!vis[i])&#123; suc = false; break; &#125; &#125; if(suc) cout &lt;&lt; &quot;Jolly\\n&quot;; else cout &lt;&lt; &quot;Not jolly\\n&quot;; &#125;&#125;"},{"title":"c082: 00118 - Mutant Flatworld Expolrers","path":"2022/02/01/c082-00118/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c082 內容給你一塊矩形土地的長寬，再依序給定每個機器人的初始位置狀況及一連串的指令集，求出每個機器人最後的位置狀況。 指令 意義 L 左轉90度 R 右轉90度 F 朝當前方向走一格 走出邊界會在掉落前的點留下標記，之後的機器人位於此處則會忽略掉落指令。 輸入第一列代表土地大小，接著為若干個機器人初始位置、方向、指令。 範例輸入5 31 1 ERFRFRFRF3 2 NFRRFLLFFRRFLL0 3 WLLFFFLFLFL 範例輸出1 1 E3 3 N LOST2 3 S 想法模擬機器人行走，若掉落，則紀錄掉落前位置。 可先用 map 將指令跟數字對應，方便操作。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int b4i[] = &#123;0, 1, 0, -1&#125;, b4j[] = &#123;1, 0, -1, 0&#125;;bool vis[100][100];map&lt;char, int&gt; mp;char mp_inv[4];int main()&#123; fastio; mp[&#x27;E&#x27;] = 0, mp[&#x27;N&#x27;] = 1, mp[&#x27;W&#x27;] = 2, mp[&#x27;S&#x27;] = 3; mp_inv[0] = &#x27;E&#x27;, mp_inv[1] = &#x27;N&#x27;, mp_inv[2] = &#x27;W&#x27;, mp_inv[3] = &#x27;S&#x27;; int m, n, x, y, dir; char pos; string order; bool suc; cin &gt;&gt; n &gt;&gt; m; while(cin &gt;&gt; x)&#123; cin &gt;&gt; y &gt;&gt; pos; cin &gt;&gt; order; dir = mp[pos]; suc = true; for(int i = 0; i &lt; order.length(); ++i)&#123; if(order[i] == &#x27;L&#x27;)&#123; ++dir; if(dir &gt; 3) dir = 0; &#125; else if(order[i] == &#x27;R&#x27;)&#123; --dir; if(dir &lt; 0) dir = 3; &#125; else &#123; int di = y + b4i[dir], dj = x + b4j[dir]; if((di &gt; m || dj &gt; n || di &lt; 0 || dj &lt; 0) &amp;&amp; !vis[y][x])&#123; vis[y][x] = true; suc = false; break; &#125; else if(di &lt;= m &amp;&amp; dj &lt;= n &amp;&amp; di &gt;= 0 &amp;&amp; dj &gt;= 0)&#123; y = di, x = dj; &#125; &#125; &#125; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; mp_inv[dir]; if(!suc) cout &lt;&lt; &quot; LOST&quot;; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c045: 00490 - Rotating Sentences","path":"2022/02/01/c045-00490/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c045 內容將輸入順時針轉 90 度輸出。 範例輸入Rene Decartes once said,“I think, therefore I am.” 範例輸出“RIe ntehiDnekc,a rttheesreofnocree sIa iadm,.“ 想法使用 getline 一次讀取一列，將全部輸入存進字串陣列，記錄最長字串長度。從最後一列開始，由後往前一行一行輸出。 程式碼 C++ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string s[100]; int c = 0, len = -50, now; while(getline(cin, s[c]))&#123; now = s[c].length(); len = max(len, now); ++c; &#125; --c; for(int i = 0; i &lt; len; ++i)&#123; for(int j = c; j &gt;= 0; --j)&#123; if(s[j].length() &lt;= i) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; s[j][i]; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c044: 10008 - What's Cryptanalysis","path":"2022/02/01/c044-10008/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c044 內容給定多列文字，計算英文字母出現次數(大小寫視為相同)，按照次數排序(若一樣則按照字母序)。 第一列有一個正整數 n ，代表有 n 列文字。 範例輸入3This is a test.Count me 1 2 3 4 5.Wow!!!! Is this question easy? 範例輸出S 7T 6I 5E 4O 3A 2H 2N 2U 2W 2C 1M 1Q 1Y 1 想法使用 getline 一次讀取一列，遍歷判斷是否為字母。開 struct 紀錄各個字母和出現次數，按照題目要求排序。 程式碼 C++ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;struct Node&#123; int num; int time;&#125;;bool cmp(Node a, Node b)&#123; if(a.time == b.time) return a.num &lt; b.num; return a.time &gt; b.time;&#125;int main()&#123; fastio; int n; string s; Node node[26]; for(int i = 0; i &lt; 26; ++i)&#123; node[i].num = i; node[i].time = 0; &#125; cin &gt;&gt; n; cin.ignore(); while(n--)&#123; getline(cin, s); for(int i = 0; i &lt; s.length(); ++i)&#123; if(isalpha(s[i]))&#123; if(isupper(s[i]))&#123; ++node[s[i] - &#x27;A&#x27;].time; &#125; else ++node[s[i] - &#x27;a&#x27;].time; &#125; &#125; &#125; sort(node, node + 26, cmp); for(int i = 0; i &lt; 26; ++i)&#123; if(node[i].time == 0) break; else cout &lt;&lt; char(node[i].num + &#x27;A&#x27;) &lt;&lt; &quot; &quot; &lt;&lt; node[i].time &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c039: 00100 - The 3n + 1 problem","path":"2022/02/01/c039-00100/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c039 內容考慮以下的演算法： 1. 輸入 n2. 印出 n3. 如果 n = 1 結束4. 如果 n 是奇數 那麼 n=3*n+15. 否則 n=n/26. GOTO 2例如輸入 22, 得到的數列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 此數列的長度稱為 cycle-length。上面提到的例子, 22 的 cycle length為 16. 給定兩個整數 i, j (0 &lt; i, j &lt; 1000000)，輸出介於 i, j 之間的數所產生的數列中最大的cycle length 。 範例輸入1 1010 1100 200201 210900 1000 範例輸出1 10 2010 1 20100 200 125201 210 89900 1000 174 想法輸入 22, 得到的數列： 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1可以發現計算一數的 cycle-length 時可以順便得到其他數的 cycle-length num cycle-length 22 16 11 15 34 14 17 13 … … 2 2 1 1 從大的數開始算，並將過程中的數也記錄下來，之後遇到就不用重複算，節省時間。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)#define mxn 1000000using namespace std;long long int cycle_len[mxn];bool vis[mxn];int main()&#123; fastio; stack&lt;long long int&gt; sta; long long int temp, c, num; cycle_len[1] = 1; vis[1] = true; for(int i = mxn - 1; i &gt; 0; --i)&#123; if(!vis[i])&#123; temp = i; while(temp != 1)&#123; sta.push(temp); if(temp &amp; 1) temp = 3 * temp + 1; else temp &gt;&gt;= 1; &#125; c = 2; while(!sta.empty())&#123; num = sta.top(); sta.pop(); if(num &lt; mxn)&#123; vis[num] = true; cycle_len[num] = c; &#125; ++c; &#125; &#125; &#125; int s, e; long long int mx; while(cin &gt;&gt; s)&#123; cin &gt;&gt; e; mx = -50; for(int i = min(s, e); i &lt;= max(s, e); ++i)&#123; mx = max(mx, cycle_len[i]); &#125; cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; mx &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c022: 10783 - Odd Sum","path":"2022/02/01/c022-10783/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c022 內容給定兩數 a, b (0 &lt;= a &lt;= b &lt;= 100)，找出 a 與 b 之間所有奇數的和。 第一列有一個整數 T (1 &lt;= T &lt;= 100)代表測資數。 範例輸入21535 範例輸出Case 1: 9Case 2: 8 想法從 a 遍歷到 b ，若是奇數則計算。 程式碼 C++ 123456789101112131415161718#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int T, a, b, sum; cin &gt;&gt; T; for(int c = 1; c &lt;= T; ++c)&#123; sum = 0; cin &gt;&gt; a &gt;&gt; b; for(int i = a; i &lt;= b; ++i)&#123; if(i &amp; 1) sum += i; &#125; cout &lt;&lt; &quot;Case &quot; &lt;&lt; c &lt;&lt; &quot;: &quot; &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"c014: 10035 - Primary Arithmetic","path":"2022/02/01/c014-10035/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c014 內容給定兩個正整數，進行加法運算，輸出產生幾次進位。 最後一列有 2 個 0 代表輸入結束。 範例輸入123 456555 555123 5940 0 範例輸出No carry operation.3 carry operations.1 carry operation. 想法使用 string 分別存取兩數，開始模擬直式運算(記得考慮各種可能的數字，我卡超久= =)。 程式碼 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string s1, s2; int carry, temp; //int c = 0; while(cin &gt;&gt; s1)&#123; cin &gt;&gt; s2; //++c; //if(c == 2077) cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2; if(s1 == &quot;0&quot; &amp;&amp; s2 == &quot;0&quot;) break; carry = temp = 0; int index_s1 = s1.length() - 1, index_s2 = s2.length() - 1; while(index_s1 &gt;= 0 &amp;&amp; index_s2 &gt;= 0)&#123; if(((s1[index_s1] - &#x27;0&#x27;) + (s2[index_s2] - &#x27;0&#x27;) + temp) &gt;= 10)&#123; ++carry; temp = 1; &#125; else temp = 0; --index_s1, --index_s2; &#125; if(index_s1 &gt;= 0 &amp;&amp; s1[index_s1] == &#x27;9&#x27; &amp;&amp; temp == 1)&#123; while(index_s1 &gt;= 0 &amp;&amp; s1[index_s1] == &#x27;9&#x27;)&#123; ++carry; --index_s1; &#125; &#125; else if(index_s2 &gt;= 0 &amp;&amp; s2[index_s2] == &#x27;9&#x27; &amp;&amp; temp == 1)&#123; while(index_s2 &gt;= 0 &amp;&amp; s2[index_s2] == &#x27;9&#x27;)&#123; ++carry; --index_s2; &#125; &#125; if(carry == 0) cout &lt;&lt; &quot;No carry operation.\\n&quot;; else if(carry == 1) cout &lt;&lt; &quot;1 carry operation.\\n&quot;; else cout &lt;&lt; carry &lt;&lt; &quot; carry operations.\\n&quot;; &#125;&#125;"},{"title":"c012: 10062 - Tell me the frequencies!","path":"2022/02/01/c012-10062/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c012 內容給定一字串，輸出各字元的ASCII值跟出現的次數(依次數由小到大，若一樣則ASCII較大者先輸出)。 範例輸入AAABBC122333 範例輸出67 166 265 3 49 150 251 3 想法使用 getline 一次讀取一列(可能有空白)，開 struct 紀錄各個ASCII值和其出現次數，再照著題目要求排序即可。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;struct Node&#123; int ascii; int time;&#125;;bool cmp(Node a, Node b)&#123; if(a.time == b.time) return a.ascii &gt; b.ascii; return a.time &lt; b.time;&#125;int main()&#123; fastio; string s; Node node[260]; while(getline(cin, s))&#123; for(int i = 0; i &lt; 260; ++i)&#123; node[i].ascii = i; node[i].time = 0; &#125; for(int i = 0; i &lt; s.length(); ++i)&#123; ++node[s[i]].time; &#125; sort(node, node + 260, cmp); for(int i = 0; i &lt; 260; ++i)&#123; if(node[i].time != 0)&#123; cout &lt;&lt; node[i].ascii &lt;&lt; &quot; &quot; &lt;&lt; node[i].time &lt;&lt; &quot;\\n&quot;; &#125; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c007: 00272 - TeX Quotes","path":"2022/01/31/c007-00272/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c007 內容給定若干列文字，將每組雙引號的第一個用``代替、第二個用’’代替。 範例輸入“To be or not to be,” quoth the Bard, “that is the question”.The programming contestant replied: “I must disagree.To `C’ or not to `C’, that is The Question!” 範例輸出``To be or not to be,’’ quoth the Bard, ``that is the question’’.The programming contestant replied: ``I must disagree.To `C’ or not to `C’, that is The Question!’’ 想法使用 getline 一次讀取一列，接著遍歷，遇到雙引號就判斷，其餘則直接輸出。 程式碼 C++ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; string s; bool dir = true; while(getline(cin, s))&#123; for(int i = 0; i &lt; s.length(); ++i)&#123; if(s[i] == &#x27;&quot;&#x27;)&#123; if(dir)&#123; cout &lt;&lt; &quot;``&quot;; dir = !dir; &#125; else &#123; cout &lt;&lt; &quot;&#x27;&#x27;&quot;; dir = !dir; &#125; &#125; else cout &lt;&lt; s[i]; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"c004: 10812 - Beat the Spread!","path":"2022/01/31/c004-10812/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=c004 內容給定兩數之和 a 、差 b (正數)，判斷兩數是否為大於等於 0 的整數。 第一列數字代表有幾組測資。如果條件成立，輸出兩數(大的在前)，不成立則輸出「impossible」。 範例輸入440 2020 405 1100 1 範例輸出30 10impossible3 2impossible 想法解二元一次聯立方程式。X + Y = aX - Y = b 程式碼 C++ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, s, d, x, y; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt; d; if((s+d) &amp; 1) cout &lt;&lt; &quot;impossible&quot;; else &#123; x = (s+d) &gt;&gt; 1; y = s-x; if(y &lt; 0) cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"a743: 10420 - List of Conquests","path":"2022/01/31/a743-10420/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a743 內容給定一整數 n (n &lt;= 2000)代表有 n 列，每列有多個字串，計算每列第一個字串出現的次數，並按照字典序排序。 範例輸入3Spain Donna ElviraEngland Jane DoeSpain Donna Anna 範例輸出England 1Spain 2 想法使用 getline 一次讀取一列，接著用 stringstream 將第一個字串分割出來，存入 map 計算次數，利用 map 的特性(字串默認排序為字典序)，遍歷一次即可。 程式碼 C++ 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n; string s, country; stringstream ss; map &lt;string, int&gt; mp; map &lt;string, int&gt; ::iterator iter; cin &gt;&gt; n &gt;&gt; ws; while(n--)&#123; getline(cin, s); ss &lt;&lt; s; ss &gt;&gt; country; ++mp[country]; ss.str(&quot;&quot;), ss.clear(); &#125; for(iter = mp.begin(); iter != mp.end(); ++iter)&#123; cout &lt;&lt; iter -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; iter -&gt; second &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;"},{"title":"a741: 10101 - Bangla Numbers","path":"2022/01/31/a741-10101/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a741 內容Bangla numbers 與十進制配對如下。‘kuti’ (10000000), ‘lakh’ (100000), ‘hajar’ (1000), ‘shata’ (100) 給定一十進位數字 n (0 &lt;= n &lt; 10^15)，輸出其對應的Bangla numbers。 範例輸入2376445897458973958 範例輸出1. 23 hajar 7 shata 642. 45 lakh 89 hajar 7 shata 45 kuti 89 lakh 73 hajar 9 shata 58 想法如果 n &gt; 1 kuti，就把 n 分兩半，像是 45897458973958 -&gt; 4589745 8973958，接著從’kuti’依序除到’shata’。 用long long 存 n。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int mp[] = &#123;10000000, 100000, 1000, 100&#125;; string s[] = &#123;&quot;kuti&quot;, &quot;lakh&quot;, &quot;hajar&quot;, &quot;shata&quot;&#125;; long long n, temp; int c = 0; while(cin &gt;&gt; n)&#123; cout &lt;&lt; ++c &lt;&lt; &quot;.&quot;; if(n == 0)&#123; cout &lt;&lt; &quot; 0\\n&quot;; continue; &#125; if(n / mp[0] != 0)&#123; temp = n / mp[0]; for(int i = 0; i &lt; 4; ++i)&#123; if(temp / mp[i] != 0)&#123; cout &lt;&lt; &quot; &quot; &lt;&lt; temp / mp[i] &lt;&lt; &quot; &quot; &lt;&lt; s[i]; temp %= mp[i]; &#125; &#125; if(temp != 0) cout &lt;&lt; &quot; &quot; &lt;&lt; temp; cout &lt;&lt; &quot; &quot; &lt;&lt; s[0]; n %= mp[0]; &#125; for(int i = 1; i &lt; 4; ++i)&#123; if(n / mp[i] != 0)&#123; cout &lt;&lt; &quot; &quot; &lt;&lt; n / mp[i] &lt;&lt; &quot; &quot; &lt;&lt; s[i]; n %= mp[i]; &#125; &#125; if(n != 0) cout &lt;&lt; &quot; &quot; &lt;&lt; n; cout &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"a737: 10041 - Vito's family","path":"2022/01/31/a737-10041/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a737 內容給定一數列，求一數使其到每個數之距離和為最小，輸出最小距離和。 輸入的第一列有一個整數代表以下有多少組測試資料。每組測資一列，第一個整數 r (0 &lt; r &lt; 500)代表數列長度，接下來的 r 個整數s1,s2,……sr為數列值（0 &lt; si &lt;30000）。 範例輸入32 2 43 2 4 64 2 1 999 5 範例輸出241001 想法排序後取中位數，再掃一遍已排序數列找距離。 程式碼 C++ 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int T, n, mp[500], sum, mid; cin &gt;&gt; T; while(T--)&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; mp[i]; sort(mp, mp + n); sum = 0; if(n &amp; 1) mid = mp[n &gt;&gt; 1]; else mid = (mp[n &gt;&gt; 1] + mp[(n &gt;&gt; 1) - 1]) &gt;&gt; 1; for(int i = 0; i &lt; n; ++i)&#123; sum += abs(mp[i] - mid); &#125; cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"a134: 00948 - Fibonaccimal Base","path":"2022/01/31/a134-00948/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a134 內容給一組十進位數字，以費氏進位輸出(如下)。17 = 1 0 0 1 0 113+3+1 = 13 8 5 3 2 1 輸入的第一行含有一個數字 N，代表以下有幾個數字 ( 1 ≤ N ≤ 500)。接下來有 N 行，每行有一個小於 100 000 000 的正整數。數字不一定按順序出現。 範例輸入1012345678910 範例輸出1 = 1 (fib)2 = 10 (fib)3 = 100 (fib)4 = 101 (fib)5 = 1000 (fib)6 = 1001 (fib)7 = 1010 (fib)8 = 10000 (fib)9 = 10001 (fib)10 = 10010 (fib) 想法先建一個足夠大的陣列存費氏數列，將陣列由大跑到小，如果小於輸入值，則更新。 注意不可出現相鄰的1。 程式碼 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int N, dp[41], num; bool suc, beg; cin &gt;&gt; N; memset(dp, 0, sizeof(dp)); dp[0] = 1; dp[1] = 2; for(int i = 2; i &lt; 41; ++i)&#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; while(N--)&#123; cin &gt;&gt; num; suc = true; beg = false; cout &lt;&lt; num &lt;&lt; &quot; = &quot;; for(int i = 40; i &gt;= 0; --i)&#123; if(dp[i] &lt;= num)&#123; beg = true; if(suc)&#123; num -= dp[i]; cout &lt;&lt; 1; suc = false; &#125; else &#123; cout &lt;&lt; 0; suc = true; &#125; &#125; else if(beg)&#123; cout &lt;&lt; 0; suc = true; &#125; &#125; cout &lt;&lt; &quot; (fib)\\n&quot;; &#125;&#125;"},{"title":"a132: 10931 - Parity","path":"2022/01/31/a132-10931/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a132 內容整數 n (1 &lt;= n &lt; 2^31) 的「同位元」定義為：其二進位表示法中每位元的和再除以 2 的餘數。例如：21 -&gt; 10101 有三個 1，因此它的同位元為 3。 不斷輸入n求同位元，n = 0 結束。 範例輸入1210210 範例輸出The parity of 1 is 1 (mod 2).The parity of 10 is 1 (mod 2).The parity of 1010 is 2 (mod 2).The parity of 10101 is 3 (mod 2). 想法將n不斷除以二，取餘數放進stack，因堆疊特性，pop出來即為二進制。 程式碼 C++ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; int n, c; stack &lt;int&gt; sta; while(cin &gt;&gt; n &amp;&amp; n)&#123; c = 0; cout &lt;&lt; &quot;The parity of &quot;; while(n &gt; 0)&#123; if(n &amp; 1)&#123; ++c; sta.push(1); &#125; else sta.push(0); n &gt;&gt;= 1; &#125; while(!sta.empty())&#123; cout &lt;&lt; sta.top(); sta.pop(); &#125; cout &lt;&lt; &quot; is &quot; &lt;&lt; c &lt;&lt; &quot; (mod 2).\\n&quot;; &#125; return 0;&#125;"},{"title":"a012: 10055 - Hashmat the Brave Warrior","path":"2022/01/31/a012-10055/","text":"CPE 一顆星選集 49 道必考題 題目連結:https://zerojudge.tw/ShowProblem?problemid=a012 內容Hashmat是一個勇敢的將領，他帶著年輕的士兵從這個城市移動到另一個城市與敵人對抗。在打仗之前他會計算己方與敵方士兵的數目差距，來決定是要開打或不開打。Hashmat的士兵數絕不會比敵人的士兵數大。 給定兩整數a, b (0 &lt;= a, b &lt; 2^63)，輸出兩數之差(正數)。 範例輸入10 1214 10 範例輸出24 想法輸入值可能大於2^31，要用long long。 用abs()取兩數之差的絕對值。 程式碼 C++ 123456789101112#include &lt;bits/stdc++.h&gt;#define fastio ios_base::sync_with_stdio(false), cin.tie(nullptr)using namespace std;int main()&#123; fastio; long long int a, b; while(cin &gt;&gt; a)&#123; cin &gt;&gt; b; cout &lt;&lt; abs(a - b) &lt;&lt; &quot;\\n&quot;; &#125;&#125;"},{"title":"a002: 簡易加法","path":"2022/01/31/a002-簡易加法/","text":"a002: 簡易加法 題目連結:https://zerojudge.tw/ShowProblem?problemid=a002 內容請寫一個程式，讀入兩個數字，並求出它們的和。 範例輸入5 101 2 範例輸出153 想法基本輸入輸出。 程式碼 C++ 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout&lt;&lt; a + b; return 0;&#125;"},{"title":"a001: 哈囉","path":"2022/01/31/a001-哈囉/","text":"a001: 哈囉 題目連結:https://zerojudge.tw/ShowProblem?problemid=a001 內容學習所有程式語言的第一個練習題請寫一個程式，可以讀入指定的字串，並且輸出指定的字串。 比如：輸入字串 “world”, 則請輸出 “hello, world” 範例輸入worldC++hello, C++ 範例輸出hello, worldhello, C++hello, Taiwan 想法基本輸入輸出。 程式碼 C++ 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; string a; cin &gt;&gt; a; cout &lt;&lt; &quot;hello, &quot; &lt;&lt; a; return 0;&#125;"},{"title":"starburst","path":"2022/01/30/2022-1-30-starburst/","text":"星爆氣流斬認識星爆星光連流擊（日語：星光連流撃／スターバースト・ストリーム sutābāsuto storīmu，英語：Starburst Stream，舊譯星爆氣流斬[1]），是日本輕小說《刀劍神域》主角桐人持雙劍「闡釋者」、「逐闇者」時所使用的招式。原本日文小說並未有該招式的漢字名稱，台灣角川中文版譯者周庭旭將其翻譯為「星爆氣流斬」；香港無綫電視J2只使用英文「Starburst Stream」。 簡介星爆氣流斬是桐人在動畫第一季第九集與樓層頭目「閃耀魔眼（The Gleameyes）」戰鬥中，以雙劍打出十六連擊的招式名稱。由於該作品當時討論度非常高，擁有許多的狂熱粉絲。因此狂熱粉絲與貶低者時常於巴哈姆特電玩資訊站爭論影響他人，引起大眾不滿而給噓；而論戰中時常出現桐人拔出雙劍的動畫截圖，久而久之形成一股「桐人必噓」的風潮。 影響這股風潮從台灣知名ACG網站「巴哈姆特電玩資訊站」的場外休憩區發展起來，從而漸漸的擴展到其他社群網站[2]。如果有角色拿著「雙刀」或是動作類似，留言裡時常會出現「C8763」洗版或給噓，並且常有相關角色的改圖 ，例如 ：「幫我撐十秒」、「這就是等級制的MMO不合理的地方」、「騙人的吧」等… 。 來源:自由的百科全書"},{"title":"Hello world","path":"2022/01/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]